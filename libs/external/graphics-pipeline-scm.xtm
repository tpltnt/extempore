;; vert shader
(define passthrough-vert
"// VERTEX SHADER
// #version 330

varying vec2 TexCoord;

void main() {
   // pass through texture coordinate
   //TexCoord =  gl_TextureMatrix[0].st * gl_MultiTexCoord0.st;
   TexCoord = gl_MultiTexCoord0.st;
   gl_FrontColor = gl_Color;
   //gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; //this same as line below
   gl_Position = ftransform();
}")


;; frag shader
(define passthrough-frag
"//  FRAGMENT SHADER
// #version 330
#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   gl_FragColor = texture2DRect(tex1,TexCoord);
}")


;; frag shader
(define greyscale-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   float grey = dot(texture2DRect(tex1,TexCoord).rgb, vec3(0.299, 0.587, 0.114));
   gl_FragColor = vec4(vec3(grey),alpha);
}")


;; sepia
(define sepia-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   float grey = dot(texture2DRect(tex1,TexCoord).rgb, vec3(0.299, 0.587, 0.114));
   gl_FragColor = vec4(grey*vec3(1.2,1.0,0.8),alpha);
}")


(define invert-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   vec4 colour = texture2DRect(tex1,TexCoord);
   gl_FragColor = vec4(1.0 - colour.rgb,alpha);
}")


(define gaussian-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
   vec4 sample[25];
   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
   }

   gl_FragColor = ((1.0  * (sample[0] + sample[4]  + sample[20] + sample[24])) +
	           (4.0  * (sample[1] + sample[3]  + sample[5]  + sample[9] + sample[15] + sample[19] + sample[21] + sample[23])) +
	           (7.0  * (sample[2] + sample[10] + sample[14] + sample[22])) +
	           (16.0 * (sample[6] + sample[8]  + sample[16] + sample[18])) +
	           (26.0 * (sample[7] + sample[11] + sample[13] + sample[17])) +
	           (41.0 * sample[12])
	           ) / 273.0;
   //gl_FragColor = vec4(1.0,0.0,0.0,1.0);
}")


;;  Blur (median filter)
(define blur-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
   gl_FragColor = vec4(0.0);

   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      gl_FragColor += texture2DRect(tex1, TexCoord + texoffset[i]);
   }

   gl_FragColor /= 25.0;
}")


;;  sharpen
(define sharpen-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
    vec4 sample[25];

    for (int i = 0; i < 25; i++)
    {
       // Sample a grid around and including our texel
       sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
    }

    gl_FragColor = 25.0 * sample[12];

    for (int i = 0; i < 25; i++)
    {
       if (i != 12)
          gl_FragColor -= sample[i];
    }
}")

(define dilate-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
   vec4 sample[25];
   vec4 maxValue = vec4(0.0);

   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);

      // Keep the maximum value
      maxValue = max(sample[i], maxValue);
   }

   gl_FragColor = maxValue;
}")


(define erode-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
    vec4 sample[25];
    vec4 minValue = vec4(1.0);

    for (int i = 0; i < 25; i++)
    {
        // Sample a grid around and including our texel
        sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);

        // Keep the minimum value
        minValue = min(sample[i], minValue);
    }
    gl_FragColor = minValue;
}")


(define edge-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
    vec4 sample[25];

    for (int i = 0; i < 25; i++)
    {
       // Sample a grid around and including our texel
       sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
    }

    gl_FragColor = 24.0 * sample[12];

    for (int i = 0; i < 25; i++)
    {
	if (i != 12)
	   gl_FragColor -= sample[i];
    }
}")


(define blend-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect baseBuf;
uniform sampler2DRect blendBuf;
uniform float       time;
uniform float       opacity;

varying vec2 TexCoord;

void main() {
    vec4 base = texture2DRect(baseBuf, TexCoord);
    vec4 blend = texture2DRect(blendBuf, TexCoord);

    vec4 result = blend + base;
         result = clamp(result, 0.0, 1.0);

    gl_FragColor = mix(base, result, opacity);
}")


;; vert shader
(define particles-vert
"// VERTEX SHADER
// GLSL 1.2 compatible

//varying vec2 TexCoord;

attribute vec2 myVertex;
attribute vec4 myColour;
attribute float mySize;
attribute vec2 myVelocity;
attribute float myState;

void main() {
   gl_PointSize = mySize;
   if(myState > 0.0) {
     gl_FrontColor = myColour;
   }else{
     gl_FrontColor = vec4(0.0,0.0,0.0,0.0);
   }
   gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * vec4(myVertex.xy,0.0,1.0);
   //TexCoord = gl_MultiTexCoord0.st;
}")

(define particles-frag
"//  FRAGMENT SHADER
// #version 330

#version 120

#extension GL_ARB_texture_rectangle : disable

uniform sampler2D tex1;

//varying vec2 TexCoord;

void main() {
   gl_FragColor = texture2D(tex1,gl_PointCoord)*gl_Color;
   //gl_FragColor = gl_Color;
}")


(define green-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex_back;
uniform sampler2DRect tex_front;
uniform vec4 color;
uniform float width;
uniform float height;
uniform float scale_front;
uniform int flipx;
uniform int flipy;

varying vec2 TexCoord;

void main() {
    vec4 base = texture2DRect(tex_back, TexCoord);
    float x = (flipx==0) ? TexCoord.x : width-TexCoord.x;
    float y = (flipy==0) ? TexCoord.y : height-TexCoord.y;
    vec4 blend = texture2DRect(tex_front, vec2(x*scale_front,y*scale_front));

    if(color == blend) {
      gl_FragColor = base;
    }else{
      gl_FragColor = blend;
    }
}")


(define dof-frag
"
#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect dBuf;
uniform sampler2DRect cBuf;
//uniform vec2 frameBufSize;
uniform float blur;
uniform float fp;  // focal point
uniform int show_depth;
uniform float dfact; // depth factor (shorten or make longer)
uniform float near;
uniform float far;

varying vec2 TexCoord;

// const float near = 0.1;
// const float far = 1000.0;
const vec2 frameBufSize = vec2(1.0,1.0);

vec4 blurKawase( const sampler2DRect tex, const vec2 texCoord, const vec2 texSize, const float iteration ) {
	// Function assumes that tex is using bilinear hardware filtering

	vec2 dUV = (iteration + 0.5) / texSize;

	vec4 col = texture2DRect( tex, texCoord + vec2( -dUV.x, dUV.y ) );	// Top left
	col += texture2DRect( tex, texCoord + dUV );		        // Top right
	col += texture2DRect( tex, texCoord + vec2( dUV.x, -dUV.y ) );      // Bottom right
	col += texture2DRect( tex, texCoord - dUV );		        // Bottom left

	return col * 0.25;
}

void main( void ) {
        // get z depth from dBuf tex
	float depth = texture2DRect(dBuf,TexCoord).x;

        // scale depth buffer
        depth *= far-near;
        depth = (far+near)-depth;
        depth = abs(depth - fp); // fp focal point

        // show_depth is true display depth buffer
        if (show_depth == 1) {
          gl_FragColor = vec4(depth,depth,depth,1.0);
        } else { // else apply depth blur
          gl_FragColor = blurKawase( cBuf, TexCoord, frameBufSize, depth * blur);
        }
}
")


(define light-vert
  "
//#version 120
#version 120
varying vec3 N, L, E, V;
varying float D;
uniform vec4 LightPos;
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main()
{
  gl_Position = ModelViewProjectionMatrix * gl_Vertex;
  vec4 vPosition = ModelViewMatrix * gl_Vertex;
  //gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * gl_Vertex;
  //vec4 vPosition = ViewMatrix * ModelMatrix * gl_Vertex;
  N = NormalMatrix * gl_Normal; //normal
  L = (LightPos - (ModelMatrix * gl_Vertex)).xyz; // vector from source to light
  if(LightPos.w == 0.0) L = LightPos.xyz; // i.e. if LightPos is already a direction vector
  D = length(L); // distance from source to light
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
}
")

(define light-frag
  "
#version 120
varying vec3 N, L, E, V;
varying float D;
uniform vec4 LightAmbient;
uniform vec4 LightDiffuse;
uniform vec4 LightSpecular;
uniform float ConstantAttenuation;
uniform float LinearAttenuation;
uniform float QuadraticAttenuation;
uniform float SpotAngle;
uniform vec4 SpotDir;
uniform float SpotExponent;
uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main()
{
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;

  vec3 NN = normalize(N); // surface normal
  vec3 LL = normalize(L); // light vector
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d
  vec4 Color = vec4(0.0,0.0,0.0,0.0);

  attenuation = 1.0 / (ConstantAttenuation + (LinearAttenuation * D) + (QuadraticAttenuation * D * D));

  spotDot = dot(-LL, normalize(SpotDir.xyz));

  if(spotDot < SpotAngle)
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient * MaterialAmbient * attenuation;
  diffuse = LightDiffuse * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular * MaterialSpecular * pf * attenuation;

  gl_FragColor = vec4((ambient + diffuse + specular).xyz,1.0);
}
")

(define simple-vert
  "
uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main() {
   gl_Position = ModelViewProjectionMatrix * gl_Vertex;
}
")

(define simple-vert-xtm
  "
uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

void main() {
   gl_Position = ModelViewProjectionMatrix * xtmVertex;
}
")

(define simple-frag
  "

void main() {
   gl_FragColor = vec4(1.0,0.0,0.0,1.0);
}
")

(define quad-vert
  "
#version 120

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

varying vec2 TexCoord;

void main() {
   TexCoord = gl_MultiTexCoord0.st;
   gl_FrontColor = gl_Color;
   gl_Position = ModelViewProjectionMatrix * gl_Vertex;
}
")

(define quad-frag
  "
uniform sampler2D tex1;
varying vec2 TexCoord;

void main() {
   gl_FragColor = texture2D(tex1,TexCoord);
}
")

(define light-and-shade-vert-xtm
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, L, E, V;
varying float D;

uniform vec4 LightPos;
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix;

varying vec4 lightVertexPosition;
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  L = (LightPos - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos.w == 0.0) L = LightPos.xyz; // i.e. if LightPos is already a direction vector
  D = length(L); // distance from source to light
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;
  lightVertexPosition = LightModelViewProjectionMatrix * xtmVertex;
}
")


(define light-and-shade-frag
  "
//#version 120
varying vec3 N, L, E, V;
varying float D;

uniform vec4 LightAmbient;
uniform vec4 LightDiffuse;
uniform vec4 LightSpecular;
uniform float ConstantAttenuation;
uniform float LinearAttenuation;
uniform float QuadraticAttenuation;
uniform float SpotAngle;
uniform vec4 SpotDir;
uniform float SpotExponent;
uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition;
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 LL = normalize(L); // light vector
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  attenuation = 1.0 / (ConstantAttenuation + (LinearAttenuation * D) + (QuadraticAttenuation * D * D));

  spotDot = dot(-LL, normalize(SpotDir.xyz));

  if(spotDot < SpotAngle)
    spotAttenuation = 0.0;

else
    spotAttenuation = pow(spotDot, SpotExponent);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient * MaterialAmbient * attenuation;
  diffuse = LightDiffuse * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition;
  lightVertexPosition2 /= lightVertexPosition2.w;

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,lightVertexPosition2.xy+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
     vec4 texcolor = LightDiffuse * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
     gl_FragColor = vec4((texcolor.xyz*shadowValue),1.0);
  } else {
     gl_FragColor = vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }
}
")


(define xtmvert-xtm
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;
  for(int i=0; j<numlights; i++, j+=1.0) {
    L[i] = (LightPos[i] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
    if(LightPos[i].w == 0.0) L[i] = LightPos[i].xyz; // i.e. if LightPos is already a direction vector
    D[i] = length(L[i]);
    lightVertexPosition[i] = LightModelViewProjectionMatrix[i] * xtmVertex;
  }
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;
}
")


(define xtmfrag
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  for(int i=0; j<numlights; i++, j+=1.0)
  {
    vec3 LL = normalize(L[i]); // light vector
    attenuation = 1.0 / (ConstantAttenuation[i] + (LinearAttenuation[i] * D[i]) + (QuadraticAttenuation[i] * D[i] * D[i]));
    spotDot = dot(-LL, normalize(SpotDir[i].xyz));

    if(spotDot < SpotAngle[i])
      spotAttenuation = 0.0;
    else
      spotAttenuation = pow(spotDot, SpotExponent[i]);

    attenuation *= spotAttenuation;

    HV = normalize(LL+EE); // half vector
    nDotLL = max(0.0, dot(NN,LL));
    nDotHV = max(0.0, dot(NN,HV));

    if(nDotLL==0.0)
      pf = 0.0;
    else
      pf = pow(nDotHV, MaterialShininess);

    ambient = LightAmbient[i] * MaterialAmbient * attenuation;
    diffuse = LightDiffuse[i] * MaterialDiffuse * nDotLL * attenuation;
    specular = LightSpecular[i] * MaterialSpecular * pf * attenuation;

    //calc shadows
    float shadowValue = 0.0;
    vec4 lightVertexPosition2 = lightVertexPosition[i];
    lightVertexPosition2 /= lightVertexPosition2.w;

    float aa = mod((j-0.5),4.0);
    float bb = floor((j-0.5)/4.0);
    vec2 offset = vec2(0.25*aa,0.25*bb);

    // softer shadowing by adding dither
    for(float x=-0.0004; x<=0.0004; x+=0.0002) {
      for(float y=-0.0004; y<=0.0004; y+=0.0002) {
        if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
          shadowValue+=1.0;
      }
    }
    shadowValue/=16.0;

    if(IsTextured>0.5) {
      vec4 texcolor = LightDiffuse[i] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
      outcolor += vec4((texcolor.xyz*shadowValue),1.0);
    } else {
      outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
    }
  }
  float nl = numlights;
  if(numlights<0.5) {
    nl = 1.0;
    float dotE = max(0.0, dot(NN,EE));
    if(IsTextured>0.5) {
      outcolor.xyz = texture2D(tex1,UVWCoord.xy).xyz*dotE;
    }else{
      outcolor.xyz = MaterialDiffuse.xyz*dotE;
    }
  }
  gl_FragColor = vec4(outcolor.xyz/nl,1.0);
}
")


(define xtmfrag_nolight
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  float dotE = max(0.0, dot(NN,EE));
  if(IsTextured>0.5) {
    outcolor.xyz = texture2D(tex1,UVWCoord.xy).xyz*dotE;
  }else{
    outcolor.xyz = MaterialDiffuse.xyz*dotE;
  }
  gl_FragColor = vec4(outcolor.xyz,1.0);
}
")

(define xtmvert0
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;

  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;
}
")

(define xtmvert1
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;

  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;
}
")

(define xtmfrag0
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  float dotE = max(0.0, dot(NN,EE));
  if(IsTextured>0.5) {
    outcolor.xyz = texture2D(tex1,UVWCoord.xy).xyz*dotE;
  }else{
    outcolor.xyz = MaterialDiffuse.xyz*dotE;
  }
  gl_FragColor = vec4(outcolor.xyz,1.0);
}
")


(define xtmfrag1
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    vec4 texcolor = LightDiffuse[0] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  gl_FragColor = vec4(outcolor.xyz/numlights,1.0);
}
")

(define xtmvert2
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;

  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  L[1] = (LightPos[1] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[1].w == 0.0) L[1] = LightPos[1].xyz; // i.e. if LightPos is already a direction vector
  D[1] = length(L[1]);
  lightVertexPosition[1] = LightModelViewProjectionMatrix[1] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;
}
")

(define xtmfrag2
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 texcolor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  // light 1
  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    vec4 texcolor = LightDiffuse[0] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 2
  j += 1.0;
  LL = normalize(L[1]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[1] + (LinearAttenuation[1] * D[1]) + (QuadraticAttenuation[1] * D[1] * D[1]));
  spotDot = dot(-LL, normalize(SpotDir[1].xyz));

  if(spotDot < SpotAngle[1])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[1]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[1] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[1] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[1] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[1];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[1] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  gl_FragColor = vec4(outcolor.xyz/numlights,1.0);
}
")

(define xtmvert3
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;

  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  L[1] = (LightPos[1] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[1].w == 0.0) L[1] = LightPos[1].xyz; // i.e. if LightPos is already a direction vector
  D[1] = length(L[1]);
  lightVertexPosition[1] = LightModelViewProjectionMatrix[1] * xtmVertex;

  L[2] = (LightPos[2] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[2].w == 0.0) L[2] = LightPos[2].xyz; // i.e. if LightPos is already a direction vector
  D[2] = length(L[2]);
  lightVertexPosition[2] = LightModelViewProjectionMatrix[2] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;
}
")

(define xtmfrag3
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 texcolor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  // light 1
  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[0] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 2
  j += 1.0;
  LL = normalize(L[1]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[1] + (LinearAttenuation[1] * D[1]) + (QuadraticAttenuation[1] * D[1] * D[1]));
  spotDot = dot(-LL, normalize(SpotDir[1].xyz));

  if(spotDot < SpotAngle[1])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[1]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[1] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[1] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[1] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[1];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[1] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 3
  j += 1.0;
  LL = normalize(L[2]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[2] + (LinearAttenuation[2] * D[2]) + (QuadraticAttenuation[2] * D[2] * D[2]));
  spotDot = dot(-LL, normalize(SpotDir[2].xyz));

  if(spotDot < SpotAngle[2])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[2]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[2] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[2] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[2] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[2];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[2] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  gl_FragColor = vec4(outcolor.xyz/numlights,1.0);
}
")

(define xtmvert4
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;

  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  L[1] = (LightPos[1] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[1].w == 0.0) L[1] = LightPos[1].xyz; // i.e. if LightPos is already a direction vector
  D[1] = length(L[1]);
  lightVertexPosition[1] = LightModelViewProjectionMatrix[1] * xtmVertex;

  L[2] = (LightPos[2] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[2].w == 0.0) L[2] = LightPos[2].xyz; // i.e. if LightPos is already a direction vector
  D[2] = length(L[2]);
  lightVertexPosition[2] = LightModelViewProjectionMatrix[2] * xtmVertex;

  L[3] = (LightPos[3] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[3].w == 0.0) L[3] = LightPos[3].xyz; // i.e. if LightPos is already a direction vector
  D[3] = length(L[3]);
  lightVertexPosition[3] = LightModelViewProjectionMatrix[3] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;
}
")

(define xtmfrag4
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 texcolor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  // light 1
  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[0] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 2
  j += 1.0;
  LL = normalize(L[1]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[1] + (LinearAttenuation[1] * D[1]) + (QuadraticAttenuation[1] * D[1] * D[1]));
  spotDot = dot(-LL, normalize(SpotDir[1].xyz));

  if(spotDot < SpotAngle[1])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[1]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[1] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[1] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[1] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[1];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[1] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 3
  j += 1.0;
  LL = normalize(L[2]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[2] + (LinearAttenuation[2] * D[2]) + (QuadraticAttenuation[2] * D[2] * D[2]));
  spotDot = dot(-LL, normalize(SpotDir[2].xyz));

  if(spotDot < SpotAngle[2])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[2]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[2] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[2] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[2] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[2];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[2] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 4
  j += 1.0;
  LL = normalize(L[3]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[3] + (LinearAttenuation[3] * D[3]) + (QuadraticAttenuation[3] * D[3] * D[3]));
  spotDot = dot(-LL, normalize(SpotDir[3].xyz));

  if(spotDot < SpotAngle[3])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[3]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[3] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[3] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[3] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[3];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[3] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  gl_FragColor = vec4(outcolor.xyz/numlights,1.0);
}
")

(define xtmvert5
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;

  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  L[1] = (LightPos[1] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[1].w == 0.0) L[1] = LightPos[1].xyz; // i.e. if LightPos is already a direction vector
  D[1] = length(L[1]);
  lightVertexPosition[1] = LightModelViewProjectionMatrix[1] * xtmVertex;

  L[2] = (LightPos[2] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[2].w == 0.0) L[2] = LightPos[2].xyz; // i.e. if LightPos is already a direction vector
  D[2] = length(L[2]);
  lightVertexPosition[2] = LightModelViewProjectionMatrix[2] * xtmVertex;

  L[3] = (LightPos[3] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[3].w == 0.0) L[3] = LightPos[3].xyz; // i.e. if LightPos is already a direction vector
  D[3] = length(L[3]);
  lightVertexPosition[3] = LightModelViewProjectionMatrix[3] * xtmVertex;

  L[4] = (LightPos[4] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[4].w == 0.0) L[4] = LightPos[4].xyz; // i.e. if LightPos is already a direction vector
  D[4] = length(L[4]);
  lightVertexPosition[4] = LightModelViewProjectionMatrix[4] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;
}
")

(define xtmfrag5
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 texcolor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  // light 1
  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[0] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 2
  j += 1.0;
  LL = normalize(L[1]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[1] + (LinearAttenuation[1] * D[1]) + (QuadraticAttenuation[1] * D[1] * D[1]));
  spotDot = dot(-LL, normalize(SpotDir[1].xyz));

  if(spotDot < SpotAngle[1])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[1]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[1] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[1] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[1] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[1];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[1] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 3
  j += 1.0;
  LL = normalize(L[2]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[2] + (LinearAttenuation[2] * D[2]) + (QuadraticAttenuation[2] * D[2] * D[2]));
  spotDot = dot(-LL, normalize(SpotDir[2].xyz));

  if(spotDot < SpotAngle[2])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[2]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[2] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[2] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[2] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[2];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[2] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 4
  j += 1.0;
  LL = normalize(L[3]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[3] + (LinearAttenuation[3] * D[3]) + (QuadraticAttenuation[3] * D[3] * D[3]));
  spotDot = dot(-LL, normalize(SpotDir[3].xyz));

  if(spotDot < SpotAngle[3])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[3]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[3] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[3] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[3] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[3];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[3] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 5
  j += 1.0;
  LL = normalize(L[4]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[4] + (LinearAttenuation[4] * D[4]) + (QuadraticAttenuation[4] * D[4] * D[4]));
  spotDot = dot(-LL, normalize(SpotDir[4].xyz));

  if(spotDot < SpotAngle[4])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[4]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[4] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[4] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[4] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[4];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[4] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  gl_FragColor = vec4(outcolor.xyz/numlights,1.0);
}
")

(define quad-vert
  "
#version 120

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

varying vec2 TexCoord;

void main() {
   TexCoord = gl_MultiTexCoord0.st;
   gl_FrontColor = gl_Color;
   gl_Position = ModelViewProjectionMatrix * gl_Vertex;
}
")

(define dof_frag
"
#version 120
uniform sampler2D dBuf;
uniform sampler2D cBuf;
uniform float blur;
uniform float dof;
uniform float fp;  // focal point
uniform int show_depth;
uniform float near;
uniform float far;
uniform vec2 frameBufSize;

varying vec2 TexCoord;

vec4 blurKawase( const sampler2D tex, const vec2 texCoord, const vec2 texSize, const float iteration ) {
	// Function assumes that tex is using bilinear hardware filtering

	vec2 dUV = (iteration + 0.5) / texSize;

	vec4 col = texture2D( tex, texCoord + vec2( -dUV.x, dUV.y ) );	// Top left
	col += texture2D( tex, texCoord + dUV );		        // Top right
	col += texture2D( tex, texCoord + vec2( dUV.x, -dUV.y ) );      // Bottom right
	col += texture2D( tex, texCoord - dUV );		        // Bottom left

	return col * 0.25;
}

void main( void ) {
        // get z depth from dBuf tex
	float depth = texture2D(dBuf,TexCoord).x;

        // linearly scale depth buffer
        depth = (near*2.0) / ((far+near) - (depth*(far-near)));
        // depth to focal point
        depth = log(1.0+abs(depth-fp)) / log(dof);

        // show_depth is true display depth buffer
        if (show_depth == 1) {
          gl_FragColor = vec4(depth,depth,depth,1.0);
        } else { // else apply depth blur
          gl_FragColor = blurKawase( cBuf, TexCoord, frameBufSize, depth * blur);
        }
        // gl_FragColor = texture2D(cBuf,TexCoord);
}
")

(define xtm_render_setup
  (lambda (w h . args)
    (xtm_render_init_quad_shader quad-vert quad-frag)
    (xtm_render_init_dof_shader quad-vert dof_frag)
    (xtm_render_init_simple_shader simple-vert-xtm simple-frag)
    (xtm_render_init_light_shaders xtmvert0 xtmfrag0 xtmvert1 xtmfrag1 xtmvert2 xtmfrag2 xtmvert3 xtmfrag3 xtmvert4 xtmfrag4 xtmvert5 xtmfrag5)
    (cond ((null? args)
           (xtm_render_setup_a (real->integer w) (real->integer h)
                               simple-vert-xtm simple-frag
                               xtmvert-xtm xtmfrag xtmfrag_nolight
                               quad-vert quad-frag))
          ((= (length args) 2)
           (xtm_render_setup_b (real->integer w) (real->integer h)
                               (car args) (cadr args)
                               simple-vert-xtm simple-frag
                               xtmvert-xtm xtmfrag xtmfrag_nolight
                               quad-vert quad-frag))
          ((= (length args) 5)
           (xtm_render_setup_c (real->integer w) (real->integer h)
                               (car args) (cadr args)
                               (caddr args) (cadddr args)
                               (car (cddddr args))
                               simple-vert-xtm simple-frag
                               xtmvert-xtm xtmfrag xtmfrag_nolight
                               quad-vert quad-frag))
          (else (print "Wrong number or args for xtm_render_setup\n")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; convenience functions for setting up a gl loop on another process

(define gl-loop
  (lambda (time delta-t)
    (gl_render)
    ;; this won't work in Scheme
    ;; (glfw_swap_buffers window)
    (let* ((cb-lookahead 0.1)
           (t (+ (now) (* cb-lookahead delta-t *second*)))
           (missed-frames (quotient (real->integer (- t time))
                                    (real->integer (* delta-t *second*))))
           (newtime (+ time (* (* (+ missed-frames 2) delta-t) *second*))))
      (if (> missed-frames 0)
          (begin (print-with-colors *impc:compiler:pretty-print-error-color* 'default #t
                                    (print "Warning"))
                 (print ": ")
                 (print-with-colors *impc:compiler:pretty-print-name-color* 'default #t
                                    (print "gl-loop"))
                 (print " couldn't handle the load, dropped ")
                 (print-with-colors *impc:compiler:pretty-print-code-color* 'default #f
                                    (print missed-frames))
                 (print " frames\n")))
      (callback (* newtime cb-lookahead) 'gl-loop newtime delta-t))))

(define xtm-setup-and-start-gl-loop
  (lambda (width height fps start-time)
    (xtm_render_setup width height)
    (gl-loop start-time (/ 1 fps))
    ;; not sure about the best way to see if this function succeeds
    #t))

(define ipc:bind-xtmrender-vars
  (lambda (proc)
    (ipc:bind-func proc 'xtm_render_init_quad_shader)
    (ipc:bind-func proc 'xtm_render_init_simple_shader)
    (ipc:bind-func proc 'xtm_render_init_light_shaders xtm_render_init_light_shaders)
    ;; frag shaders
    (ipc:define proc 'simple-frag simple-frag)
    (ipc:define proc 'quad-frag quad-frag)
    (ipc:define proc 'xtmfrag0 xtmfrag0)
    (ipc:define proc 'xtmfrag xtmfrag)
    (ipc:define proc 'xtmfrag_nolight xtmfrag_nolight)
    (ipc:define proc 'xtmfrag1 xtmfrag1)
    (ipc:define proc 'xtmfrag2 xtmfrag2)
    (ipc:define proc 'xtmfrag3 xtmfrag3)
    (ipc:define proc 'xtmfrag4 xtmfrag4)
    (ipc:define proc 'xtmfrag5 xtmfrag5)
    ;; vert shaders
    (ipc:define proc 'simple-vert-xtm simple-vert-xtm)
    (ipc:define proc 'quad-vert quad-vert)
    (ipc:define proc 'xtmvert-xtm xtmvert-xtm)
    (ipc:define proc 'xtmvert0 xtmvert0)
    (ipc:define proc 'xtmvert1 xtmvert1)
    (ipc:define proc 'xtmvert2 xtmvert2)
    (ipc:define proc 'xtmvert3 xtmvert3)
    (ipc:define proc 'xtmvert4 xtmvert4)
    (ipc:define proc 'xtmvert5 xtmvert5)
    (ipc:bind-func proc 'xtm_render_setup_a xtm_render_setup_a)
    (ipc:bind-func proc 'xtm_render_setup_b xtm_render_setup_b)
    (ipc:bind-func proc 'xtm_render_setup_c xtm_render_setup_c)
    (ipc:define proc 'xtm_render_setup xtm_render_setup)
    (ipc:bind-func proc 'xtm_render xtm_render)))

(define ipc:graphics-setup
  (lambda (proc width height fullscreen fps start-time)
    (if (not (impc:ti:closure-exists? "post"))
        (bind-func post:XTMRENDERCB
          (lambda (frame shader m v p data)
            void)))
    (if (not (impc:ti:closure-exists? "gl_render"))
        (bind-func gl_render
          (lambda ()
            (xtm_render null null null  post null)
            void)))
    (begin (ipc:bind-func proc 'gl_render gl_render)
           (ipc:bind-func proc 'post post)
           (print "Binding ")
           (print-with-colors *impc:compiler:pretty-print-name-color* 'default #t
                              (print "gl_render"))
           (print " on ")
           (print-with-colors 'cyan 'default #t (print proc))
           (print " process\nMake sure you ")
           (print-with-colors *impc:compiler:pretty-print-name-color* 'default #t
                              (print "ipc:bind-func"))
           (print " any functions which ")
           (print-with-colors *impc:compiler:pretty-print-name-color* 'default #t
                              (print "gl_render"))
           (print " calls in that process as well\ne.g. (ipc:bind-func" proc "'fn_name fn_name)\n"))
    (ipc:define proc 'gl-loop gl-loop)
    ;; (ipc:define proc 'xtm-create-gl-context xtm-create-gl-context)
    (ipc:define proc 'xtm-setup-and-start-gl-loop xtm-setup-and-start-gl-loop)
    ;; (if (not (ipc:call proc 'xtm-create-gl-context width height fullscreen))
    ;;     (print-with-colors *impc:compiler:pretty-print-error-color* 'default #t
    ;;                        (print "Error creating gl context.")))
    (begin
      (ipc:bind-xtmrender-vars proc)
      (ipc:call proc 'xtm-setup-and-start-gl-loop width height fps start-time)
      (begin (print "\nStarted xtm render loop on ")
             (print-with-colors 'cyan 'default #t (print proc))
             (print " process.\n\n")))))

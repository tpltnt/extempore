;; math.xtm -- extempore math library

;; Author: Andrew Sorensen, Ben Swift
;; Keywords: extempore

;;; Commentary:

;; This file contains math routines written in xtlang.  If you're
;; concerned about raw performance at all costs, it may be better to
;; dynamically link to BLAS or something like that.  However, because
;; everything is dynamically rebindable, there are also lots of
;; opportunities to do cool things with this library.

;; This file contains xtlang functions (and the odd data type) for
;; dealing with:
;; - vectors
;; - matrices
;; - complex numbers
;; - windowing

;;; Code:

;; lib-loading config

(sys:load "libs/aot-cache/math.xtm" 'quiet)
(sys:load-preload-check 'math)
(define *xtmlib-math-loaded* #f)

(impc:aot:suppress-aot-do
 (sys:load "libs/base/base.xtm"))
(impc:aot:insert-forms (sys:load "libs/base/base.xtm" 'quiet))

(impc:aot:insert-header "xtmmath")

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; "vector" data arrays ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; these functions deal raw (float/int) data in memory, and in general
;; just take a pointer and length arguments. It's up to the programmer
;; to make sure that the data is valid (and owned by your process). If
;; you try and do stuff with bad data, incorrect `length' arguments or
;; null pointers, you're gonna have a bad time.

;; Having said that, these things are all pretty fast & efficient, and
;; will also play really nicely with any C code you've roped in. There
;; are obviously even faster options (such as linking to BLAS or
;; LAPACK) than these but these ones are nice if you want to keep
;; everything in xtlang.

;; For more sophisticated Vector and Matrix types, see libs/core/math_ext.xtm

;; Naming conventions:

;; we use a "v" naming prefix convention for 1D vectors, and an "m"
;; previx for (row-major) matrices. Furthermore, if the function takes
;; just one vector then there's just 1 "v", but if it adds two vectors
;; together there will be 2 "v"s. Also, a couple of the functions use
;; "s" for scalar and "a" for angle

;; e.g.

;;    sum of all the elements in a vector:   vsum
;;
;;    sum of two vectors:                    vvsum
;;
;;    sum of two matrices:                   mmsum
;;
;;    rotate matrix around vector:           vmrotate

;; Remember, making sure the data pointer and length arguments make
;; sense is up to the programmer.

;; 1D sum, mean, median, mode

(bind-func vsum
  (lambda (buf:i32* len:i64)
    (let ((tot:i32 0) (i 0))
      (if (> len 3)
        (let ((chunks (/ len 4)) (vbuf:/4,i32/* (cast buf)) (vtot:/4,i32/* (salloc)))
          (vfill! vtot 0 0 0 0)
          (let ((totref (pref vtot 0)))
            (dotimes (i chunks)
              (set! totref (+ totref (pref-ptr vbuf i))))
            (set! tot (+ (vref totref 0) (vref totref 1) (vref totref 2) (vref totref 3))))
          (set! len (& len 3))
          (set! buf (pref-ptr buf (* i 4)))))
      (dotimes (i len)
        (set! tot (+ tot (pref buf i))))
      tot)))

(bind-func vsum
  (lambda (buf:i64* len:i64)
    (let ((tot 0) (i 0))
      (if (> len 1)
        (let ((chunks (/ len 2)) (vbuf:/2,i64/* (cast buf)) (vtot:/2,i64/* (salloc)))
          (vfill! vtot 0 0)
          (let ((totref (pref vtot 0)))
            (dotimes (i chunks)
                (set! totref (+ totref (pref-ptr vbuf i))))
            (set! tot (+ (vref totref 0) (vref totref 1))))
        (set! len (& len 1))
        (set! buf (pref-ptr buf (* i 2)))))
      (dotimes (i len)
        (set! tot (+ tot (pref buf i))))
      tot)))

(bind-func vsum
  (lambda (buf:float* len:i64)
    (let ((tot:float 0.) (i 0))
      (if (> len 3)
        (let ((chunks (/ len 4)) (vbuf:/4,float/* (cast buf)) (vtot:/4,float/* (salloc)))
          (vfill! vtot 0. 0. 0. 0.)
          (let ((totref (pref vtot 0)))
            (dotimes (i chunks)
              (set! totref (+ totref (pref-ptr vbuf i))))
            (set! tot (+ (vref totref 0) (vref totref 1) (vref totref 2) (vref totref 3))))
          (set! len (& len 3))
          (set! buf (pref-ptr buf (* i 4)))))
      (dotimes (i len)
        (set! tot (+ tot (pref buf i))))
      tot)))

(bind-func vsum
  (lambda (buf:double* len:i64)
    (let ((tot:double 0.) (i 0))
      (if (> len 1)
        (let ((chunks (/ len 2)) (vbuf:/2,double/* (cast buf)) (vtot:/2,double/* (salloc)))
          (vfill! vtot 0. 0.)
          (let ((totref (pref vtot 0)))
            (dotimes (i chunks)
                (set! totref (+ totref (pref-ptr vbuf i))))
            (set! tot (+ (vref totref 0) (vref totref 1))))
        (set! len (& len 1))
        (set! buf (pref-ptr buf (* i 2)))))
      (dotimes (i len)
        (set! tot (+ tot (pref buf i))))
      tot)))

;; even for ints, you probably want a floating-point answer for the
;; mean - these ones return doubles to minimize the chance of
;; precision error

(bind-func vmean
  (lambda (buf:i32* len:i64)
    (/ (i32tod (vsum buf len)) (convert len))))

(bind-func vmean
  (lambda (buf:i64* len:i64)
    (/ (i64tod (vsum buf len)) (convert len))))

(bind-func vmean
  (lambda (buf:float* len:i64)
    (/ (vsum buf len) (convert len))))

(bind-func vmean
  (lambda (buf:double* len:i64)
    (/ (vsum buf len) (convert len))))

(bind-func vmin
  (lambda (buf:i32* len:i64)
    (let ((min_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (< (pref buf i) min_val)
            (set! min_val (pref buf i))))
      min_val)))

(bind-func vmin
  (lambda (buf:i64* len:i64)
    (let ((min_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (< (pref buf i) min_val)
            (set! min_val (pref buf i))))
      min_val)))

(bind-func vmin
  (lambda (buf:float* len:i64)
    (let ((min_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (< (pref buf i) min_val)
            (set! min_val (pref buf i))))
      min_val)))

(bind-func vmin
  (lambda (buf:double* len:i64)
    (let ((min_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (< (pref buf i) min_val)
            (set! min_val (pref buf i))))
      min_val)))

(bind-func vmax
  (lambda (buf:i32* len:i64)
    (let ((max_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (> (pref buf i) max_val)
            (set! max_val (pref buf i))))
      max_val)))

(bind-func vmax
  (lambda (buf:i64* len:i64)
    (let ((max_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (> (pref buf i) max_val)
            (set! max_val (pref buf i))))
      max_val)))

(bind-func vmax
  (lambda (buf:float* len:i64)
    (let ((max_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (> (pref buf i) max_val)
            (set! max_val (pref buf i))))
      max_val)))

(bind-func vmax
  (lambda (buf:double* len:i64)
    (let ((max_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (> (pref buf i) max_val)
            (set! max_val (pref buf i))))
      max_val)))

(bind-func vprint
  "print a packed i32* buffer"
  (lambda (buf:i32* len ncols)
    (doloop (i len)
      (printf "buf[%. 3lld] = %. 6d " i (pref buf i))
      (if (= (% i ncols) (- ncols 1))
          (println)))
    (println)))

(bind-func vprint
  "print a packed i32* buffer"
  (lambda (buf len)
    (vprint:[void,i32*,i64,i64]* buf len 1)))

(bind-func vprint
  "print a packed i64* buffer"
  (lambda (buf:i64* len ncols)
    (doloop (i len)
      (printf "buf[%. 3lld] = %. 6lld " i (pref buf i))
      (if (= (% i ncols) (- ncols 1))
          (println)))
    (println)))

(bind-func vprint
  "print a packed i64* buffer"
  (lambda (buf len)
    (vprint:[void,i64*,i64,i64]* buf len 1)))

(bind-func vprint
  "print a packed float* buffer"
  (lambda (buf:float* len ncols)
    (doloop (i len)
      (printf "buf[%. 3lld] = %.4f " i (convert (pref buf i) double))
      (if (= (% i ncols) (- ncols 1))
          (println)))
    (println)))

(bind-func vprint
  "print a packed float* buffer"
  (lambda (buf len)
    (vprint:[void,float*,i64,i64]* buf len 1)))

(bind-func vprint
  "print a packed double* buffer"
  (lambda (buf:double* len ncols)
    (doloop (i len)
      (printf "buf[%. 3lld] = %.4f " i (pref buf i))
      (if (= (% i ncols) (- ncols 1))
          (println)))
    (println)))

(bind-func vprint
  "print a packed double* buffer"
  (lambda (buf len)
    (vprint:[void,double*,i64,i64]* buf len 1)))

;; other naming options: sparse/dense, stride/unstride

(bind-func vcopy_unpack
  "take a packed float* buffer and copy it into a sparse representation"
  (lambda (src:float* dest:float* stride neighbors srclen)
    (doloop (i srclen)
      (doloop (j neighbors)
        (pset! dest (+ (* stride i) j) (pref src (+ (* neighbors i) j)))))))

(bind-func vcopy_unpack
  "take a packed double* buffer and copy it into a sparse representation"
  (lambda (src:double* dest:double* stride neighbors srclen)
    (doloop (i srclen)
      (doloop (j neighbors)
        (pset! dest (+ (* stride i) j) (pref src (+ (* neighbors i) j)))))))

(bind-func vcopy_pack
  "take a sparse float* buffer and copy it into a packed representation"
  (lambda (src:float* dest:float* stride neighbors srclen)
    (doloop (i srclen)
      (doloop (j neighbors)
        (pset! dest (+ (* neighbors i) j) (pref src (+ (* stride i) j)))))))

(bind-func vcopy_pack
  "take a sparse double* buffer and copy it into a packed representation"
  (lambda (src:double* dest:double* stride neighbors srclen)
    (doloop (i srclen)
      (doloop (j neighbors)
        (pset! dest (+ (* neighbors i) j) (pref src (+ (* stride i) j)))))))

(bind-func vnormalise
  (lambda (v1:float* len:i64 result:float*)
    (let ((mag 0.0)
          (i 0))
      (dotimes (i len)
        (set! mag (+ mag (* (pref v1 i) (pref v1 i)))))
      (set! mag (sqrt mag))
      (dotimes (i len)
        (pset! result i (/ (pref v1 i) mag)))
      void)))

(bind-func vnormalise
  (lambda (v1:double* len:i64 result:double*)
    (let ((mag 0.0)
          (i 0))
      (dotimes (i len)
        (set! mag (+ mag (* (pref v1 i) (pref v1 i)))))
      (set! mag (sqrt mag))
      (dotimes (i len)
        (pset! result i (/ (pref v1 i) mag)))
      void)))

(bind-func vvdot
  (let ((i 0))
    (lambda (v1:float* v2:float* len:i64)
      (let ((res 0.0))
        (dotimes (i len)
          (set! res (+ res (* (pref v1 i) (pref v2 i)))))
        res))))

(bind-func vvdot
  (let ((i 0))
    (lambda (v1:double* v2:double* len:i64)
      (let ((res 0.0))
        (dotimes (i len)
          (set! res (+ res (* (pref v1 i) (pref v2 i)))))
        res))))

;; for 3d only SO NO LGTH
(bind-func vvcross
  (let ((i 0))
    (lambda (v1:float* v2:float* result:float*)
      (pfill! result
              (- (* (pref v1 1) (pref v2 2))
                 (* (pref v2 1) (pref v1 2)))
              (- (* (pref v2 0) (pref v1 2))
                 (* (pref v1 0) (pref v2 2)))
              (- (* (pref v1 0) (pref v2 1))
                 (* (pref v2 0) (pref v1 1))))
      void)))

;; for 3d only SO NO LGTH
(bind-func vvcross
  (let ((i 0))
    (lambda (v1:double* v2:double* result:double*)
      (pfill! result
              (- (* (pref v1 1) (pref v2 2))
                 (* (pref v2 1) (pref v1 2)))
              (- (* (pref v2 0) (pref v1 2))
                 (* (pref v1 0) (pref v2 2)))
              (- (* (pref v1 0) (pref v2 1))
                 (* (pref v2 0) (pref v1 1))))
      void)))

(bind-func vsmul
  (lambda (v1:float* s:float len:i64 result:float*)
    (let ((i 0))
      (dotimes (i len)
        (pset! result i (* s (pref v1 i))))
      void)))

(bind-func vsmul
  (lambda (v1:double* s:double len:i64 result:double*)
    (let ((i 0))
      (dotimes (i len)
        (pset! result i (* s (pref v1 i))))
      void)))

(bind-func vsdiv
  (lambda (v1:float* s:float len:i64 result:float*)
    (let ((i 0))
      (dotimes (i len)
        (pset! result i (/ (pref v1 i) s)))
      void)))

(bind-func vsdiv
  (lambda (v1:double* s:double len:i64 result:double*)
    (let ((i 0))
      (dotimes (i len)
        (pset! result i (/ (pref v1 i) s)))
      void)))

(bind-func vvsum
  (let ((i 0))
    (lambda (v1:float* v2:float* len:i64 result:float*)
      (dotimes (i len)
        (pset! result i (+ (pref v1 i) (pref v2 i))))
      void)))

(bind-func vvsum
  (let ((i 0))
    (lambda (v1:double* v2:double* len:i64 result:double*)
      (dotimes (i len)
        (pset! result i (+ (pref v1 i) (pref v2 i))))
      void)))

(bind-func vvsub
  (let ((i 0))
    (lambda (v1:float* v2:float* len:i64 result:float*)
      (dotimes (i len)
        (pset! result i (- (pref v1 i) (pref v2 i))))
      void)))

(bind-func vvsub
  (let ((i 0))
    (lambda (v1:double* v2:double* len:i64 result:double*)
      (dotimes (i len)
        (pset! result i (- (pref v1 i) (pref v2 i))))
      void)))

(bind-func vvmul
  (let ((i 0))
    (lambda (v1:float* v2:float* len:i64 v3:float*)
      (dotimes (i len)
        (pset! v3 i (* (pref v1 i) (pref v2 i))))
      void)))

(bind-func vvmul
  (let ((i 0))
    (lambda (v1:double* v2:double* len:i64 v3:double*)
      (dotimes (i len)
        (pset! v3 i (* (pref v1 i) (pref v2 i))))
      void)))

(bind-func vmag
  (lambda (v:float* len:i64)
    (let ((mag 0.0)
          (i 0))
      (dotimes (i len)
        (set! mag (+ mag (* (pref v i) (pref v i)))))
      (sqrt mag))))

(bind-func vmag
  (lambda (v:double* len:i64)
    (let ((mag 0.0)
          (i 0))
      (dotimes (i len)
        (set! mag (+ mag (* (pref v i) (pref v i)))))
      (sqrt mag))))

;; Quaternions

(bind-func vaquat
  "@param v - axis vector (3d)
@param angle - angle in radians
@param result - quaternion (4d vector xyzw) in which to store the result"
  (lambda (v:float* angle:float result:float*)
    (let ((m (vmag v 3))
          (s (/ (sin (* 0.5 angle)) m)))
      (pfill! result
              (* (pref v 0) s) (* (pref v 1) s) (* (pref v 2) s)
              (cos (* 0.5 angle)))
      void)))

(bind-func vaquat
  "@param v - axis vector (3d)
@param angle - angle in radians
@param result - quaternion (4d vector xyzw) in which to store the result"
  (lambda (v:double* angle:double result:double*)
    (let ((m (vmag v 3))
          (s (/ (sin (* 0.5 angle)) m)))
      (pfill! result
              (* (pref v 0) s) (* (pref v 1) s) (* (pref v 2) s)
              (cos (* 0.5 angle)))
      void)))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; "matrix" data arrays ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; helper macros for calculating row/column major indices

(bind-macro
  "helper macro for 2D column-major indexing"
  (colmaj_idx_2D r c nrows)
  `(+ (* ,c ,nrows) ,r))

(bind-macro
  "helper macro for 2D row-major indexing"
  (rowmaj_idx_2D r c ncols)
  `(+ ,c (* ,r ,ncols)))

(bind-func mprint
  (lambda (m:float* nrows:i64 ncols:i64)
    (let ((i 0) (j 0))
      (printf "[")
      (dotimes (j nrows)
        (printf "[")
        (dotimes (i ncols)
          (printf " %f" (ftod (pref m (rowmaj_idx_2D i j ncols)))))
        (printf " ]"))
      (printf "]")
      void)))

(bind-func mprint
  (lambda (m:double* nrows:i64 ncols:i64)
    (let ((i 0) (j 0))
      (printf "[")
      (dotimes (j nrows)
        (printf "[")
        (dotimes (i ncols)
          (printf " %f" (pref m (rowmaj_idx_2D i j ncols))))
        (printf " ]"))
      (printf "]")
      void)))

(bind-func mprint
  (lambda (m:i32* nrows:i64 ncols:i64)
    (let ((i 0) (j 0))
      (printf "[")
      (dotimes (j nrows)
        (printf "[")
        (dotimes (i ncols)
          (printf " %d" (pref m (rowmaj_idx_2D i j ncols))))
        (printf " ]"))
      (printf "]")
      void)))

(bind-func mprint
  (lambda (m:i64* nrows:i64 ncols:i64)
    (let ((i 0) (j 0))
      (printf "[")
      (dotimes (j nrows)
        (printf "[")
        (dotimes (i ncols)
          (printf " %lld" (pref m (rowmaj_idx_2D i j ncols))))
        (printf " ]"))
      (printf "]")
      void)))

(bind-func mmmul
  (lambda (m1:float* r1:i64 c1:i64 m2:float* r2:i64 c2:i64 result:float*)
    (if (= c1 r2)
        (let ((r 0) (c 0) (k 0))
          (dotimes (r r1)
            (dotimes (c c2)
              (pset! result (+ c (* r c2)) 0.0)
              (dotimes (k c1)
                (pset! result (+ c (* r c2))
                       (+ (pref result (+ c (* r c2)))
                          (* (pref m1 (+ k (* r c1)))
                             (pref m2 (+ (* k c2) c))))))))
          result)
        (begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
                       r1 c1 r2 c2)
               (cast null float*)))))

(bind-func mmmul
  (lambda (m1:double* r1:i64 c1:i64 m2:double* r2:i64 c2:i64 result:double*)
    (if (= c1 r2)
        (let ((r 0) (c 0) (k 0))
          (dotimes (r r1)
            (dotimes (c c2)
              (pset! result (+ c (* r c2)) 0.0)
              (dotimes (k c1)
                (pset! result (+ c (* r c2))
                       (+ (pref result (+ c (* r c2)))
                          (* (pref m1 (+ k (* r c1)))
                             (pref m2 (+ (* k c2) c))))))))
          result)
        (begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
                       r1 c1 r2 c2)
               (cast null double*)))))

(bind-func mmmul
  (lambda (m1:i32* r1:i64 c1:i64 m2:i32* r2:i64 c2:i64 result:i32*)
    (if (= c1 r2)
        (let ((r 0) (c 0) (k 0))
          (dotimes (r r1)
            (dotimes (c c2)
              (pset! result (+ c (* r c2)) 0)
              (dotimes (k c1)
                (pset! result (+ c (* r c2))
                       (+ (pref result (+ c (* r c2)))
                          (* (pref m1 (+ k (* r c1)))
                             (pref m2 (+ (* k c2) c))))))))
          result)
        (begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
                       r1 c1 r2 c2)
               (cast null i32*)))))

(bind-func mmmul
  (lambda (m1:i64* r1:i64 c1:i64 m2:i64* r2:i64 c2:i64 result:i64*)
    (if (= c1 r2)
        (let ((r 0) (c 0) (k 0))
          (dotimes (r r1)
            (dotimes (c c2)
              (pset! result (+ c (* r c2)) 0)
              (dotimes (k c1)
                (pset! result (+ c (* r c2))
                       (+ (pref result (+ c (* r c2)))
                          (* (pref m1 (+ k (* r c1)))
                             (pref m2 (+ (* k c2) c))))))))
          result)
        (begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
                       r1 c1 r2 c2)
               (cast null i64*)))))


;; optimized 4x4 matrix only!!!
;; NEED TO ALSO DO integers and doubles!!
(bind-func mmmul
  (lambda (m1:float* m2:float* result:float*)
    (let ((row1:/4,float/* (cast (pref-ptr m2 0)))
          (row2:/4,float/* (cast (pref-ptr m2 4)))
          (row3:/4,float/* (cast (pref-ptr m2 8)))
          (row4:/4,float/* (cast (pref-ptr m2 12)))
          (out:/4,float/* (cast result))
          (tmp:/4,float/* null) (i 0))
      (dotimes (i 4)
        (set! tmp (cast (pref-ptr m1 (* 4 i))))
        (let ((a (vshuffle tmp null 0 0 0 0))
              (b (vshuffle tmp null 1 1 1 1))
              (c (vshuffle tmp null 2 2 2 2))
              (d (vshuffle tmp null 3 3 3 3)))
          (pset! out i
                 (+ (+ (* a row1)
                       (* b row2))
                    (+ (* c row3)
                       (* d row4))))))
      result)))

(bind-func mtrans
  (lambda (m1:float* nrows:i64 ncols:i64 result:float*)
    (let ((i 0) (j 0))
      (dotimes (i nrows)
        (dotimes (j ncols)
          (pset! result (+ (* j ncols) i)
                 (pref m1 (+ (* i ncols) j)))))
      result)))

(bind-func mtranspose
  (lambda (m1:double* nrows:i64 ncols:i64 result:double*)
    (let ((i 0) (j 0))
      (dotimes (i nrows)
        (dotimes (j ncols)
          (pset! result (+ (* j ncols) i)
                 (pref m1 (+ (* i ncols) j)))))
      result)))

(bind-func mdeterminant
  "matrix determinant - matrix must be square (= nrows ncols)"
  (lambda (m1:float* nrows:i64)
    (if (= nrows 1) (pref m1 0)
        (let ((det:float 0.0) (s:float 1.0)
              (c 0) (i 0) (j 0) (m 0) (n 0)
              (mb:float* (salloc (* nrows nrows))))
          (dotimes (c nrows)
            (set! m 0) (set! n 0)
            (dotimes (i nrows)
              (dotimes (j nrows)
                (pset! mb (+ (* i nrows) j) 0.0)
                (if (and (<> i 0) (<> j c))
                    (begin
                      (pset! mb (+ (* m (- nrows 1)) n)
                             (pref m1 (+ (* i nrows) j)))
                      (if (< n (- nrows 2))
                          (set! n (+ n 1))
                          (begin
                            (set! n 0)
                            (set! m (+ m 1)))))
                    (begin 1))))
            (set! det (+ det (* s (* (pref m1 c)
                                     (mdeterminant mb (- nrows 1))))))
            (set! s (* -1.0 s)))
          det))))

(bind-func mdeterminant
  "matrix determinant - matrix must be square (= nrows ncols)"
  (lambda (m1:double* nrows:i64)
    (if (= nrows 1) (pref m1 0)
        (let ((det:double 0.0) (s:double 1.0)
              (c 0) (i 0) (j 0) (m 0) (n 0)
              (mb:double* (salloc (* nrows nrows))))
          (dotimes (c nrows)
            (set! m 0) (set! n 0)
            (dotimes (i nrows)
              (dotimes (j nrows)
                (pset! mb (+ (* i nrows) j) 0.0)
                (if (and (<> i 0) (<> j c))
                    (begin
                      (pset! mb (+ (* m (- nrows 1)) n)
                             (pref m1 (+ (* i nrows) j)))
                      (if (< n (- nrows 2))
                          (set! n (+ n 1))
                          (begin
                            (set! n 0)
                            (set! m (+ m 1)))))
                    (begin 1))))
            (set! det (+ det (* s (* (pref m1 c)
                                     (mdeterminant mb (- nrows 1))))))
            (set! s (* -1.0 s)))
          det))))

(bind-func minverse
  "matrix inverse - matrix must be square (= nrows ncols)"
  (lambda (m1:float* nrows:i64 result:float*)
    (let ((m2:float* (salloc (* nrows nrows)))
          (fac:float* (salloc (* nrows nrows)))
          (d:float 0.0)
          (i 0) (j 0) (m 0) (n 0) (q:i64 0) (p:i64 0))
      (dotimes (q nrows)
        (dotimes (p nrows)
          (set! m 0)
          (set! n 0)
          (dotimes (i nrows)
            (dotimes (j nrows)
              (pset! m2 (+ (* i nrows) j) 0.0)
              (if (and (<> i q) (<> j p))
                  (begin
                    (pset! m2 (+ (* m (- nrows 1)) n)
                           (pref m1 (+ (* i nrows) j)))
                    (if (< n (- nrows 2))
                        (set! n (+ n 1))
                        (begin
                          (set! n 0)
                          (set! m (+ m 1)))))
                  (begin 1))))
          (pset! fac (+ (* q nrows) p)
                 (* (pow -1.0 (i64tof (+ q p)))
                    (mdeterminant m2 (- nrows 1))))))
      (dotimes (i nrows)
        (dotimes (j nrows)
          (pset! m2 (+ (* i nrows) j)
                 (pref fac (+ (* j nrows) i)))))
      (set! d (mdeterminant m1 nrows))
      (dotimes (i nrows)
        (dotimes (j nrows)
          (pset! result (+ (* i nrows) j)
                 (/ (pref m2 (+ (* i nrows) j)) d))))
      void)))

(bind-func minverse
  "matrix inverse - matrix must be square (= nrows ncols)"
  (lambda (m1:double* nrows:i64 result:double*)
    (let ((m2:double* (salloc (* nrows nrows)))
          (fac:double* (salloc (* nrows nrows)))
          (d:double 0.0)
          (i 0) (j 0) (m 0) (n 0) (q:i64 0) (p:i64 0))
      (dotimes (q nrows)
        (dotimes (p nrows)
          (set! m 0)
          (set! n 0)
          (dotimes (i nrows)
            (dotimes (j nrows)
              (pset! m2 (+ (* i nrows) j) 0.0)
              (if (and (<> i q) (<> j p))
                  (begin
                    (pset! m2 (+ (* m (- nrows 1)) n)
                           (pref m1 (+ (* i nrows) j)))
                    (if (< n (- nrows 2))
                        (set! n (+ n 1))
                        (begin
                          (set! n 0)
                          (set! m (+ m 1)))))
                  (begin 1))))
          (pset! fac (+ (* q nrows) p)
                 (* (pow -1.0 (i64tod (+ q p)))
                    (mdeterminant m2 (- nrows 1))))))
      (dotimes (i nrows)
        (dotimes (j nrows)
          (pset! m2 (+ (* i nrows) j)
                 (pref fac (+ (* j nrows) i)))))
      (set! d (mdeterminant m1 nrows))
      (dotimes (i nrows)
        (dotimes (j nrows)
          (pset! result (+ (* i nrows) j)
                 (/ (pref m2 (+ (* i nrows) j)) d))))
      void)))

(bind-func mcopy
  (lambda (src:float* row col dest:float*)
    (memcpy (cast dest i8*) (cast src i8*) (* row col 4))
    void))

(bind-func mcopy
  (lambda (src:double* row col dest:double*)
    (memcpy (cast dest i8*) (cast src i8*) (* row col 8))
    void))


(bind-func varotate
  "calcuate rotation matrix around vector

This function is particularly useful in graphics, so it's
column-major (the same as OpenGL)

@param axis - the unit vector around which you want to rotate
@param theta - the angle (radians) by which to rotate
@param result - a pointer to memory to store the calculated 4x4 rotation matrix in"
  (lambda (axis:float* theta:float result:float*)
    (let ((x (pref axis 0))
          (y (pref axis 1))
          (z (pref axis 2))
          (cost (cos theta))
          (sint (sin theta))
          (mcost (- 1.0 cost)))
      (pset! result 0 (+ cost (* (* x x) mcost)))
      (pset! result 1 (+ (* (* y x) mcost) (* z sint)))
      (pset! result 2 (- (* (* z x) mcost) (* y sint)))
      (pset! result 3 0.0)
      (pset! result 4 (- (* (* x y) mcost) (* z sint)))
      (pset! result 5 (+ cost (* (* y y) mcost)))
      (pset! result 6 (+ (* (* z y) mcost) (* x sint)))
      (pset! result 7 0.0)
      (pset! result 8 (+ (* (* x z) mcost) (* y sint)))
      (pset! result 9 (- (* (* y z) mcost) (* x sint)))
      (pset! result 10 (+ cost (* (* z z) mcost)))
      (pset! result 11 0.0)
      (pset! result 12 0.0)
      (pset! result 13 0.0)
      (pset! result 14 0.0)
      (pset! result 15 1.0)
      result)))

(bind-func varotate
  "calcuate rotation matrix around vector

This function is particularly useful in graphics, so it's
column-major (the same as OpenGL)

@param axis - the unit vector around which you want to rotate
@param theta - the angle (radians) by which to rotate
@param result - a pointer to memory to store the calculated 4x4 rotation matrix in"
  (lambda (axis:double* theta:double result:double*)
    (let ((x (pref axis 0))
          (y (pref axis 1))
          (z (pref axis 2))
          (cost (cos theta))
          (sint (sin theta))
          (mcost (- 1.0 cost)))
      (pset! result 0 (+ cost (* (* x x) mcost)))
      (pset! result 1 (+ (* (* y x) mcost) (* z sint)))
      (pset! result 2 (- (* (* z x) mcost) (* y sint)))
      (pset! result 3 0.0)
      (pset! result 4 (- (* (* x y) mcost) (* z sint)))
      (pset! result 5 (+ cost (* (* y y) mcost)))
      (pset! result 6 (+ (* (* z y) mcost) (* x sint)))
      (pset! result 7 0.0)
      (pset! result 8 (+ (* (* x z) mcost) (* y sint)))
      (pset! result 9 (- (* (* y z) mcost) (* x sint)))
      (pset! result 10 (+ cost (* (* z z) mcost)))
      (pset! result 11 0.0)
      (pset! result 12 0.0)
      (pset! result 13 0.0)
      (pset! result 14 0.0)
      (pset! result 15 1.0)
      result)))

;;;;;;;;;;;;;
;; sorting ;;
;;;;;;;;;;;;;

;; in-place quicksort

(bind-func vquicksort
  (lambda (buf:double* left right)
    (if (< left right)
        (let ((tmp 0.0)
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

(bind-func vquicksort
  (lambda (buf:float* left right)
    (if (< left right)
        (let ((tmp 0.0)
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

(bind-func vquicksort
  (lambda (buf:i64* left right)
    (if (< left right)
        (let ((tmp 0)
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

(bind-func vquicksort
  (lambda (buf:i32* left right)
    (if (< left right)
        (let ((tmp 0)
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

(bind-func vquicksort
  (lambda (buf:i16* left right)
    (if (< left right)
        (let ((tmp 0)
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

(bind-func vquicksort
  (lambda (buf:i8* left right)
    (if (< left right)
        (let ((tmp 0)
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

;; this generic vquicksort works but is SUPER slow!
(bind-func vquicksort:[void,!a,i64,i64]*
  (lambda (buf left right)
    (if (< left right)
        (let ((tmp (convert 0))
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

;; default vector sort - quicksort the whole buffer

(bind-func vsort
  (lambda (buf:double* len)
    (vquicksort buf 0 (- len 1))
    buf))

(bind-func vsort
  (lambda (buf:float* len)
    (vquicksort buf 0 (- len 1))
    buf))

(bind-func vsort
  (lambda (buf:i64* len)
    (vquicksort buf 0 (- len 1))
    buf))

(bind-func vsort
  (lambda (buf:i32* len)
    (vquicksort buf 0 (- len 1))
    buf))

(bind-func vsort
  (lambda (buf:i16* len)
    (vquicksort buf 0 (- len 1))
    buf))

(bind-func vsort
  (lambda (buf:i8* len)
    (vquicksort buf 0 (- len 1))
    buf))

(bind-func vmedian
  (lambda (buf:float* len:i64)
    (let ((h (vsort buf len))
          (idx (dtoi64 (ceil (/ (i64tod len) 2.0)))))
      (if (evenp len)
          (/ (+ (pref h idx) (pref h (- idx 1))) 2.0)
          (pref h idx)))))

(bind-func vmedian
  (lambda (buf:double* len:i64)
    (let ((h (vsort buf len))
          (idx (dtoi64 (ceil (/ (i64tod len) 2.0)))))
      (if (evenp len)
          (/ (+ (pref h idx) (pref h (- idx 1))) 2.0)
          (pref h idx)))))

;; naive mode needs to be replaced!
(bind-func vmode
  (lambda (buf:float* len:i64)
    (let ((h (vsort buf len))
          (p NaNf) (l 0) (largest 0) (j:float 0.0) (i 0))
      (dotimes (i len)
        (if (= p (pref buf i))
            (set! l (+ l 1)) ;; increment l
            (set! l 0))
        (set! p (pref buf i))
        (if (> l largest)
            (begin
              (set! largest l)
              (set! j p))))
      j)))

(bind-func vmode
  (lambda (buf:double* len:i64)
    (let ((h (vsort buf len))
          (p NaN) (l 0) (largest 0) (j:double 0.0) (i 0))
      (dotimes (i len)
        (if (= p (pref buf i))
            (set! l (+ l 1)) ;; increment l
            (set! l 0))
        (set! p (pref buf i))
        (if (> l largest)
            (begin
              (set! largest l)
              (set! j p))))
      j)))

;;;;;;;;;;;;;;
;; Rational ;;
;;;;;;;;;;;;;;

;; xtlang's rational number type and helper functions

(bind-type Rational <i64,i64> (printer? . #f))

(bind-func Rat
  (lambda (a b)
    (if (< b 0)
        (begin (set! a (* -1 a))
               (set! b (* -1 b))))
    (let ((r:Rational* (salloc)))
      (tset! r 0 a)
      (tset! r 1 b)
      (pref r 0))))

(bind-func Rational_greatest_common_divisor
  (lambda (m:i64 n:i64)
    (if (and (= m 0) (= n 0))
        -1
        (let ((r 0))
          (if (< m 0) (set! m (* m -1)))
          (if (< n 0) (set! n (* n -1)))
          (while (not (= n 0))
            (set! r (% m n))
            (set! m n)
            (set! n r))
          m))))

(bind-func Rational_reduce
  (lambda (a:Rational)
    (let ((gcd (Rational_greatest_common_divisor (tref a 0)
                                            (tref a 1))))
      (Rat (/ (tref a 0) gcd)
           (/ (tref a 1) gcd)))))

(bind-func print
  (lambda (a:Rational)
    (let ((reduced (Rational_reduce a)))
      (printf "%lld/%lld" (tref reduced 0) (tref reduced 1))) void))

;; conversion

(bind-func rtod
  (lambda (a:Rational)
    (/ (i64tod (tref a 0)) (i64tod (tref a 1)))))

(bind-func rtof
  (lambda (a:Rational)
    (/ (i64tof (tref a 0)) (i64tof (tref a 1)))))

(bind-func rtoi64
  (lambda (a:Rational)
    (dtoi64 (rtod a))))

(bind-func rtoi32
  (lambda (a:Rational)
    (dtoi32 (rtod a))))

(bind-func rtoi16
  (lambda (a:Rational)
    (dtoi16 (rtod a))))

(bind-func rtoi8
  (lambda (a:Rational)
    (dtoi8 (rtod a))))

(bind-func rtoi1
  (lambda (a:Rational)
    (dtoi1 (rtod a))))

;; rational multiplication

(bind-func xtm_multiplication
  (lambda (a:Rational b:Rational)
    (Rational_reduce
     (Rat (* (tref a 0) (tref b 0))
          (* (tref a 1) (tref b 1))))))

(bind-func xtm_multiplication
  (lambda (a:Rational b:i64)
    (Rat (* (tref a 0) b) (* (tref a 1) 1))))

(bind-func xtm_multiplication
  (lambda (b:i64 a:Rational)
    (Rat (* (tref a 0) b) (* (tref a 1) 1))))

(bind-func xtm_multiplication
  (lambda (a:Rational b:i32)
    (Rat (* (tref a 0) (i32toi64 b)) (* (tref a 1) 1))))

(bind-func xtm_multiplication
  (lambda (b:i32 a:Rational)
    (Rat (* (tref a 0) (i32toi64 b)) (* (tref a 1) 1))))

(bind-func xtm_multiplication
  (lambda (a:Rational b:i8)
    (Rat (* (tref a 0) (i8toi64 b)) (* (tref a 1) 1))))

(bind-func xtm_multiplication
  (lambda (b:i8 a:Rational)
    (Rat (* (tref a 0) (i8toi64 b)) (* (tref a 1) 1))))

(bind-func xtm_multiplication
  (lambda (a:Rational b:i1)
    (Rat (* (tref a 0) (i1toi64 b)) (* (tref a 1) 1))))

(bind-func xtm_multiplication
  (lambda (b:i1 a:Rational)
    (Rat (* (tref a 0) (i1toi64 b)) (* (tref a 1) 1))))

(bind-func xtm_multiplication
  (lambda (a:Rational b:double)
    (* b (/ (convert (tref a 0) double) (convert (tref a 1) double)))))

(bind-func xtm_multiplication
  (lambda (b:double a:Rational)
    (* b (/ (convert (tref a 0) double) (convert (tref a 1) double)))))

(bind-func xtm_multiplication
  (lambda (a:Rational b:float)
    (* b (/ (convert (tref a 0) float) (convert (tref a 1) float)))))

(bind-func xtm_multiplication
  (lambda (b:float a:Rational)
    (* b (/ (convert (tref a 0) float) (convert (tref a 1) float)))))

;; rational division

(bind-func xtm_division
  (lambda (a:Rational b:Rational)
    (Rational_reduce
     (Rat (* (tref a 0) (tref b 1))
          (* (tref a 1) (tref b 0))))))

(bind-func xtm_division
  (lambda (a:Rational b:i64)
    (Rat (* (tref a 0) b) (* (tref a 1) 1))))

(bind-func xtm_division
  (lambda (a:i64 b:Rational)
    (Rat (* (tref b 1) a) (* (tref b 0) 1))))

(bind-func xtm_division
  (lambda (a:Rational b:i32)
    (Rat (* (tref a 0) (i32toi64 b)) (* (tref a 1) 1))))

(bind-func xtm_division
  (lambda (a:i32 b:Rational)
    (Rat (* (tref b 1) (i32toi64 a)) (* (tref b 0) 1))))

(bind-func xtm_division
  (lambda (a:Rational b:i8)
    (Rat (* (tref a 0) (i8toi64 b)) (* (tref a 1) 1))))

(bind-func xtm_division
  (lambda (a:i8 b:Rational)
    (Rat (* (tref b 1) (i8toi64 a)) (* (tref b 0) 1))))

(bind-func xtm_division
  (lambda (a:Rational b:i1)
    (Rat (* (tref a 0) (i1toi64 b)) (* (tref a 1) 1))))

(bind-func xtm_division
  (lambda (a:i1 b:Rational)
    (Rat (* (tref b 1) (i1toi64 a)) (* (tref b 0) 1))))

(bind-func xtm_division
  (lambda (a:Rational b:double)
    (/ (/ (convert (tref a 0) double) (convert (tref a 1) double)) b)))

(bind-func xtm_division
  (lambda (b:double a:Rational)
    (/ (/ (convert (tref a 0) double) (convert (tref a 1) double)) b)))

(bind-func xtm_division
  (lambda (a:Rational b:float)
    (/ (/ (convert (tref a 0) float) (convert (tref a 1) float)) b)))

(bind-func xtm_division
  (lambda (b:float a:Rational)
    (/ (/ (convert (tref a 0) float) (convert (tref a 1) float)) b)))

;; Rational addition

(bind-func xtm_addition
  (lambda (a:Rational b:Rational)
    (let ((denom_a (tref a 1))
          (denom_b (tref b 1)))
      (Rational_reduce
       (Rat (+ (* (tref a 0) denom_b) (* (tref b 0) denom_a))
            (* denom_a denom_b))))))

(bind-func xtm_addition
  (lambda (a:Rational b:i64)
    (Rat (+ (tref a 0) (* (tref a 1) b)) (tref a 1))))

(bind-func xtm_addition
  (lambda (b:i64 a:Rational)
    (Rat (+ (tref a 0) (* (tref a 1) b)) (tref a 1))))

(bind-func xtm_addition
  (lambda (a:Rational b:i32)
    (Rat (+ (tref a 0) (* (tref a 1) (i32toi64 b))) (tref a 1))))

(bind-func xtm_addition
  (lambda (b:i32 a:Rational)
    (Rat (+ (tref a 0) (* (tref a 1) (i32toi64 b))) (tref a 1))))

(bind-func xtm_addition
  (lambda (a:Rational b:i8)
    (Rat (+ (tref a 0) (* (tref a 1) (i8toi64 b))) (tref a 1))))

(bind-func xtm_addition
  (lambda (b:i8 a:Rational)
    (Rat (+ (tref a 0) (* (tref a 1) (i8toi64 b))) (tref a 1))))

(bind-func xtm_addition
  (lambda (a:Rational b:i1)
    (Rat (+ (tref a 0) (* (tref a 1) (i1toi64 b))) (tref a 1))))

(bind-func xtm_addition
  (lambda (b:i1 a:Rational)
    (Rat (+ (tref a 0) (* (tref a 1) (i1toi64 b))) (tref a 1))))

(bind-func xtm_addition
  (lambda (a:Rational b:double)
    (+ (/ (convert (tref a 0) double) (convert (tref a 1) double)) b)))

(bind-func xtm_addition
  (lambda (b:double a:Rational)
    (+ (/ (convert (tref a 0) double) (convert (tref a 1) double)) b)))

(bind-func xtm_addition
  (lambda (a:Rational b:float)
    (+ (/ (convert (tref a 0) float) (convert (tref a 1) float)) b)))

(bind-func xtm_addition
  (lambda (b:float a:Rational)
    (+ (/ (convert (tref a 0) float) (convert (tref a 1) float)) b)))

;; Rational subtraction

(bind-func xtm_subtraction
  (lambda (a:Rational b:Rational)
    (let ((denom_a (tref a 1))
          (denom_b (tref b 1)))
      (Rational_reduce
       (Rat (- (* (tref a 0) denom_b) (* (tref b 0) denom_a))
            (* denom_a denom_b))))))

(bind-func xtm_subtraction
  (lambda (a:Rational b:i64)
    (Rat (- (tref a 0) (* (tref a 1) b)) (tref a 1))))

(bind-func xtm_subtraction
  (lambda (b:i64 a:Rational)
    (Rat (- (tref a 0) (* (tref a 1) b)) (tref a 1))))

(bind-func xtm_subtraction
  (lambda (a:Rational b:i32)
    (Rat (- (tref a 0) (* (tref a 1) (i32toi64 b))) (tref a 1))))

(bind-func xtm_subtraction
  (lambda (b:i32 a:Rational)
    (Rat (- (tref a 0) (* (tref a 1) (i32toi64 b))) (tref a 1))))

(bind-func xtm_subtraction
  (lambda (a:Rational b:i8)
    (Rat (- (tref a 0) (* (tref a 1) (i8toi64 b))) (tref a 1))))

(bind-func xtm_subtraction
  (lambda (b:i8 a:Rational)
    (Rat (- (tref a 0) (* (tref a 1) (i8toi64 b))) (tref a 1))))

(bind-func xtm_subtraction
  (lambda (a:Rational b:i1)
    (Rat (- (tref a 0) (* (tref a 1) (i1toi64 b))) (tref a 1))))

(bind-func xtm_subtraction
  (lambda (b:i1 a:Rational)
    (Rat (- (tref a 0) (* (tref a 1) (i1toi64 b))) (tref a 1))))

(bind-func xtm_subtraction
  (lambda (a:Rational b:double)
    (- (/ (convert (tref a 0) double) (convert (tref a 1) double)) b)))

(bind-func xtm_subtraction
  (lambda (b:double a:Rational)
    (- (/ (convert (tref a 0) double) (convert (tref a 1) double)) b)))

(bind-func xtm_subtraction
  (lambda (a:Rational b:float)
    (- (/ (convert (tref a 0) float) (convert (tref a 1) float)) b)))

(bind-func xtm_subtraction
  (lambda (b:float a:Rational)
    (- (/ (convert (tref a 0) float) (convert (tref a 1) float)) b)))

;; Rational equality

(bind-func xtm_equal
  (lambda (a:Rational b:Rational)
    (let ((reduced_a (Rational_reduce a))
          (reduced_b (Rational_reduce b)))
      (and (= (tref reduced_a 0)
              (tref reduced_b 0))
           (= (tref reduced_a 1)
              (tref reduced_b 1))))))

(bind-func xtm_equal
  (lambda (a:Rational b:i64)
    (xtm_equal:[i1,Rational,Rational]* a (Rat b 1))))

(bind-func xtm_equal
  (lambda (b:i64 a:Rational)
    (xtm_equal:[i1,Rational,Rational]* (Rat b 1) a)))

(bind-func xtm_equal
  (lambda (a:Rational b:i32)
    (xtm_equal:[i1,Rational,Rational]* a (Rat (i32toi64 b) 1))))

(bind-func xtm_equal
  (lambda (b:i32 a:Rational)
    (xtm_equal:[i1,Rational,Rational]* (Rat (i32toi64 b) 1) a)))

(bind-func xtm_equal
  (lambda (a:Rational b:i8)
    (xtm_equal:[i1,Rational,Rational]* a (Rat (i8toi64 b) 1))))

(bind-func xtm_equal
  (lambda (b:i8 a:Rational)
    (xtm_equal:[i1,Rational,Rational]* (Rat (i8toi64 b) 1) a)))

(bind-func xtm_equal
  (lambda (a:Rational b:i1)
    (xtm_equal:[i1,Rational,Rational]* a (Rat (i1toi64 b) 1))))

(bind-func xtm_equal
  (lambda (b:i1 a:Rational)
    (xtm_equal:[i1,Rational,Rational]* (Rat (i1toi64 b) 1) a)))

;; Rational inequality

(bind-func xtm_notequal
  (lambda (a:Rational b:Rational)
    (let ((reduced_a (Rational_reduce a))
          (reduced_b (Rational_reduce b)))
      (or (<> (tref reduced_a 0)
              (tref reduced_b 0))
          (<> (tref reduced_a 1)
              (tref reduced_b 1))))))

(bind-func xtm_notequal
  (lambda (a:Rational b:i64)
    (xtm_notequal:[i1,Rational,Rational]* a (Rat b 1))))

(bind-func xtm_notequal
  (lambda (b:i64 a:Rational)
    (xtm_notequal:[i1,Rational,Rational]* (Rat b 1) a)))

(bind-func xtm_notequal
  (lambda (a:Rational b:i32)
    (xtm_notequal:[i1,Rational,Rational]* a (Rat (i32toi64 b) 1))))

(bind-func xtm_notequal
  (lambda (b:i32 a:Rational)
    (xtm_notequal:[i1,Rational,Rational]* (Rat (i32toi64 b) 1) a)))

(bind-func xtm_notequal
  (lambda (a:Rational b:i8)
    (xtm_notequal:[i1,Rational,Rational]* a (Rat (i8toi64 b) 1))))

(bind-func xtm_notequal
  (lambda (b:i8 a:Rational)
    (xtm_notequal:[i1,Rational,Rational]* (Rat (i8toi64 b) 1) a)))

(bind-func xtm_notequal
  (lambda (a:Rational b:i1)
    (xtm_notequal:[i1,Rational,Rational]* a (Rat (i1toi64 b) 1))))

(bind-func xtm_notequal
  (lambda (b:i1 a:Rational)
    (xtm_notequal:[i1,Rational,Rational]* (Rat (i1toi64 b) 1) a)))

;; Rational lessthan

(bind-func xtm_lessthan
  (lambda (a:Rational b:Rational)
    (< (* (tref a 0) (tref b 1))
       (* (tref b 0) (tref a 1)))))

(bind-func xtm_lessthan
  (lambda (a:Rational b:i64)
    (< (tref a 0) (* b (tref a 1)))))

(bind-func xtm_lessthan
  (lambda (b:i64 a:Rational)
    (< (tref a 0) (* b (tref a 1)))))

(bind-func xtm_lessthan
  (lambda (a:Rational b:i32)
    (< (tref a 0) (* (i32toi64 b) (tref a 1)))))

(bind-func xtm_lessthan
  (lambda (b:i32 a:Rational)
    (< (tref a 0) (* (i32toi64 b) (tref a 1)))))

(bind-func xtm_lessthan
  (lambda (a:Rational b:i8)
    (< (tref a 0) (* (i8toi64 b) (tref a 1)))))

(bind-func xtm_lessthan
  (lambda (b:i8 a:Rational)
    (< (tref a 0) (* (i8toi64 b) (tref a 1)))))

(bind-func xtm_lessthan
  (lambda (a:Rational b:i1)
    (< (tref a 0) (* (i1toi64 b) (tref a 1)))))

(bind-func xtm_lessthan
  (lambda (b:i1 a:Rational)
    (< (tref a 0) (* (i1toi64 b) (tref a 1)))))

;; Rational greaterthan

(bind-func xtm_greaterthan
  (lambda (a:Rational b:Rational)
    (> (* (tref a 0) (tref b 1))
       (* (tref b 0) (tref a 1)))))

(bind-func xtm_greaterthan
  (lambda (a:Rational b:i64)
    (> (tref a 0) (* b (tref a 1)))))

(bind-func xtm_greaterthan
  (lambda (b:i64 a:Rational)
    (> (tref a 0) (* b (tref a 1)))))

(bind-func xtm_greaterthan
  (lambda (a:Rational b:i32)
    (> (tref a 0) (* (i32toi64 b) (tref a 1)))))

(bind-func xtm_greaterthan
  (lambda (b:i32 a:Rational)
    (> (tref a 0) (* (i32toi64 b) (tref a 1)))))

(bind-func xtm_greaterthan
  (lambda (a:Rational b:i8)
    (> (tref a 0) (* (i8toi64 b) (tref a 1)))))

(bind-func xtm_greaterthan
  (lambda (b:i8 a:Rational)
    (> (tref a 0) (* (i8toi64 b) (tref a 1)))))

(bind-func xtm_greaterthan
  (lambda (a:Rational b:i1)
    (> (tref a 0) (* (i1toi64 b) (tref a 1)))))

(bind-func xtm_greaterthan
  (lambda (b:i1 a:Rational)
    (> (tref a 0) (* (i1toi64 b) (tref a 1)))))

;; rational modulo

(bind-func xtm_modulo
  (lambda (a:Rational b:Rational)
    (let ((c (/ a b))
          (n (Rat (% (tref c 0) (tref c 1)) (tref c 1))))
      (* b n))))

(bind-func xtm_modulo
  (lambda (a:Rational b:i64)
    (xtm_modulo:[Rational,Rational,Rational]* a (Rat b 1))))

(bind-func xtm_modulo
  (lambda (a:i64 b:Rational)
    (xtm_modulo:[Rational,Rational,Rational]* (Rat a 1) b)))

(bind-func xtm_modulo
  (lambda (a:Rational b:i32)
    (xtm_modulo:[Rational,Rational,Rational]* a (Rat (i32toi64 b) 1))))

(bind-func xtm_modulo
  (lambda (a:i32 b:Rational)
    (xtm_modulo:[Rational,Rational,Rational]* (Rat (i32toi64 a) 1) b)))

(bind-func xtm_modulo
  (lambda (a:Rational b:i8)
    (xtm_modulo:[Rational,Rational,Rational]* a (Rat (i8toi64 b) 1))))

(bind-func xtm_modulo
  (lambda (a:i8 b:Rational)
    (xtm_modulo:[Rational,Rational,Rational]* (Rat (i8toi64 a) 1) b)))

;;;;;;;;;; COMPLEX NUMBERS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; xtlang's complex number types and helper functions
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Complexd (double versions)

(bind-type Complexd <double,double> (printer? . #f))

(bind-func Cpxd
  (lambda (re im)
    (let ((c:Complexd* (salloc)))
      (tset! c 0 re)
      (tset! c 1 im)
      (pref c 0))))

(bind-func print
  "specialised print function for Complexd"
  (lambda (c:Complexd)
    (printf "%.2f%+.2fi"
            (tref c 0)
            (tref c 1))
    void))

(bind-func print
  "specialised print function for Complexd*"
  (lambda (c:Complexd*)
    (if (null? c)
        (printf "<Complexd 0x0>")
        (printf "%.2f%+.2fi"
                (tref c 0)
                (tref c 1)))
    void))

(bind-func toString
  "specialised toString function for Complexd"
  (lambda (c:Complexd)
    (let ((str:i8* (salloc 256)))
      (sprintf str "%.2f%+.2fi"
               (tref c 0)
               (tref c 1))
      (Str str))))

(bind-func toString
  "specialised toString function for Complexd"
  (lambda (c:Complexd*)
    (let ((str:i8* (salloc 256)))
      (if (null? c)
          (sprintf str "<Complexd 0x0>")
          (sprintf str "%.2f%+.2fi"
                   (tref c 0)
                   (tref c 1)))
      (Str str))))

(bind-func xtm_addition
  (lambda (a:Complexd b:Complexd)
    (Cpxd (+ (tref a 0) (tref b 0))
          (+ (tref a 1) (tref b 1)))))

(bind-func xtm_addition
  (lambda (a:Complexd b:double)
    (Cpxd (+ (tref a 0) b)
          (tref a 1))))

(bind-func xtm_addition
  (lambda (b:double a:Complexd)
    (Cpxd (+ (tref a 0) b)
          (tref a 1))))

(bind-func Complex_addition_bybuf
  (lambda (a:Complexd* b:Complexd* c:Complexd* len)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr c i) 0
               (+ (tref (pref-ptr a i) 0)
                  (tref (pref-ptr b i) 0)))
        (tset! (pref-ptr c i) 1
               (+ (tref (pref-ptr a i) 1)
                  (tref (pref-ptr b i) 1))))
      void)))

(bind-func xtm_subtraction
  (lambda (a:Complexd b:Complexd)
    (Cpxd (- (tref a 0) (tref b 0))
          (- (tref a 1) (tref b 1)))))

(bind-func xtm_subtraction
  (lambda (a:Complexd b:double)
    (Cpxd (- (tref a 0) b)
          (tref a 1))))

(bind-func xtm_subtraction
  (lambda (b:double a:Complexd)
    (Cpxd (- (tref a 0) b)
          (tref a 1))))

(bind-func Complex_subtraction_bybuf
  (lambda (a:Complexd* b:Complexd* c:Complexd* len)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr c i) 0
               (- (tref (pref-ptr a i) 0)
                  (tref (pref-ptr b i) 0)))
        (tset! (pref-ptr c i) 1
               (- (tref (pref-ptr a i) 1)
                  (tref (pref-ptr b i) 1))))
      void)))

(bind-func xtm_multiplication
  (lambda (a:Complexd b:Complexd)
    (Cpxd (- (* (tref a 0) (tref b 0))
             (* (tref a 1) (tref b 1)))
          (+ (* (tref a 0) (tref b 1))
             (* (tref a 1) (tref b 0))))))

(bind-func xtm_multiplication
  (lambda (a:Complexd b:double)
    (Cpxd (- (* (tref a 0) b)
             (tref a 1))
          (+ (tref a 0)
             (* (tref a 1) b)))))

(bind-func xtm_multiplication
  (lambda (b:double a:Complexd)
    (Cpxd (- (* (tref a 0) b)
             (tref a 1))
          (+ (tref a 0)
             (* (tref a 1) b)))))

(bind-func Complex_multiplication_bybuf
  (lambda (a:Complexd* b:Complexd* c:Complexd* len)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr c i) 0
               (- (* (tref (pref-ptr a i) 0)
                     (tref (pref-ptr b i) 0))
                  (* (tref (pref-ptr a i) 1)
                     (tref (pref-ptr b i) 1))))
        (tset! (pref-ptr c i) 1
               (+ (* (tref (pref-ptr a i) 0)
                     (tref (pref-ptr b i) 1))
                  (* (tref (pref-ptr a i) 1)
                     (tref (pref-ptr b i) 0)))))
      void)))

(bind-func xtm_division
  (lambda (a:Complexd b:Complexd)
    (let ((i (+ (* (tref a 0) (tref b 0))
                (* (tref a 1) (tref b 1))))
          (j (+ (* (tref b 0) (tref b 0))
                (* (tref b 1) (tref b 1))))
          (k (- (* (tref a 1) (tref b 0))
                (* (tref a 0) (tref b 1)))))
      (Cpxd (/ i j)
            (/ k j)))))

(bind-func xtm_division
  (lambda (a:Complexd b:double)
    (let ((i (+ (* (tref a 0) b)
                (tref a 1)))
          (j (* b b))
          (k (- (* (tref a 1) b)
                (tref a 0) )))
      (Cpxd (/ i j)
            (/ k j)))))

(bind-func xtm_division
  (lambda (b:double a:Complexd)
    (let ((i (+ (* (tref a 0) b)
                (tref a 1)))
          (j (* b b))
          (k (- (* (tref a 1) b)
                (tref a 0) )))
      (Cpxd (/ i j)
            (/ k j)))))

(bind-func Complex_division_bybuf
  (lambda (a:Complexd* b:Complexd* c:Complexd* len)
    (let ((i 0) (j 0.0) (k 0.0) (l 0.0))
      (dotimes (i len)
        (set! j (+ (* (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 1))))
        (set! k (+ (* (tref (pref-ptr b i) 0)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr b i) 1)
                      (tref (pref-ptr b i) 1))))
        (set! l (- (* (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 1))))
        (tset! (pref-ptr c i) 0 (/ j k))
        (tset! (pref-ptr c i) 1 (/ l k)))
      void)))

(bind-func Complex_mag
  (lambda (a:Complexd)
    (sqrt (+ (* (tref a 0) (tref a 0))
             (* (tref a 1) (tref a 1))))))

(bind-func Complex_phase
  (lambda (a:Complexd)
    (atan (/ (tref a 1) (tref a 0)))))

(bind-func Complex_conj
  (lambda (a:Complexd)
    (Cpxd (tref a 0)
          (* -1.0 (tref a 0)))))

(bind-func cart_to_pol
  (lambda (a:Complexd)
    (Cpxd (sqrt (+ (* (tref a 0) (tref a 0))
                   (* (tref a 1) (tref a 1))))
          (atan (/ (tref a 1) (tref a 0))))))

(bind-func cart_to_pol
  "transform a whole buffer cart->pol in-place"
  (lambda (a:Complexd* n:i64)
    (doloop (i n)
      (tset! (pref-ptr a i) 0
             (sqrt (+ (* (tref a 0) (tref a 0))
                      (* (tref a 1) (tref a 1)))))
      (tset! (pref-ptr a i) 1
             (atan (/ (tref a 1) (tref a 0)))))
    void))

(bind-func pol_to_cart
  (lambda (a:Complexd)
    (Cpxd (* (tref a 0) (cos (tref a 1)))
          (* (tref a 0) (sin (tref a 1))))))

(bind-func pol_to_cart
  "transform a whole buffer pol->cart in-place"
  (lambda (a:Complexd* n:i64)
    (doloop (i n)
      (tset! (pref-ptr a i) 0
             (* (tref a 0) (cos (tref a 1))))
      (tset! (pref-ptr a i) 1
             (* (tref a 0) (sin (tref a 1)))))
    void))


;; Complexf (float versions)

(bind-type Complexf <float,float> (printer? . #f))

(bind-func Cpxf
  (lambda (re im)
    (let ((c:Complexf* (salloc)))
      (tset! c 0 re)
      (tset! c 1 im)
      (pref c 0))))

(bind-func print
  "specialised print function for Complexf"
  (lambda (c:Complexf)
    (printf "%.2f%+.2fi"
            (ftod (tref c 0))
            (ftod (tref c 1)))
    void))

(bind-func print
  "specialised print function for Complexf*"
  (lambda (c:Complexf*)
    (if (null? c)
        (printf "<Complexf 0x0>")
        (printf "%.2f%+.2fi"
            (ftod (tref c 0))
            (ftod (tref c 1))))
    void))

(bind-func toString
  "specialised toString function for Complexf"
  (lambda (c:Complexf)
    (let ((str:i8* (salloc 256)))
      (sprintf str "%.2f%+.2fi"
               (ftod (tref c 0))
               (ftod (tref c 1)))
      (Str str))))

(bind-func toString
  "specialised toString function for Complexf"
  (lambda (c:Complexf*)
    (let ((str:i8* (salloc 256)))
      (if (null? c)
          (sprintf str "<Complexf 0x0>")
          (sprintf str "%.2f%+.2fi"
                   (ftod (tref c 0))
                   (ftod (tref c 1))))
      (Str str))))


(bind-func xtm_addition
  (lambda (a:Complexf b:Complexf)
    (Cpxf (+ (tref a 0) (tref b 0))
          (+ (tref a 1) (tref b 1)))))

(bind-func xtm_addition
  (lambda (a:Complexf b:float)
    (Cpxf (+ (tref a 0) b)
          (tref a 1))))

(bind-func xtm_addition
  (lambda (b:float a:Complexf)
    (Cpxf (+ (tref a 0) b)
          (tref a 1))))

(bind-func Complex_addition_bybuf
  (lambda (a:Complexf* b:Complexf* c:Complexf* len:i64)
    (if (evenp len)
        (let ((aa:/4,float/* (cast a))
              (bb:/4,float/* (cast b))
              (cc:/4,float/* (cast c))
              (k 0))
          (dotimes (k (/ len 2))
            (pset! cc k (+ (pref-ptr aa k) (pref-ptr bb k)))
            void))
        (let ((i 0))
          (dotimes (i len)
            (tset! (pref-ptr c i) 0
                   (+ (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 0)))
            (tset! (pref-ptr c i) 1
                   (+ (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 1))))
          void))))


(bind-func xtm_subtraction
  (lambda (a:Complexf b:Complexf)
    (Cpxf (- (tref a 0) (tref b 0))
          (- (tref a 1) (tref b 1)))))

(bind-func xtm_subtraction
  (lambda (a:Complexf b:float)
    (Cpxf (- (tref a 0) b)
          (tref a 1))))

(bind-func xtm_subtraction
  (lambda (b:float a:Complexf)
    (Cpxf (- (tref a 0) b)
          (tref a 1))))

(bind-func Complex_subtraction_bybuf
  (lambda (a:Complexf* b:Complexf* c:Complexf* len:i64)
    (if (evenp len)
        (let ((aa:/4,float/* (cast a))
              (bb:/4,float/* (cast b))
              (cc:/4,float/* (cast c))
              (k 0))
          (dotimes (k (/ len 2))
            (pset! cc k (- (pref-ptr aa k) (pref-ptr bb k)))
            void))
        (let ((i 0))
          (dotimes (i len)
            (tset! (pref-ptr c i) 0
                   (- (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 0)))
            (tset! (pref-ptr c i) 1
                   (- (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 1))))
          void))))

(bind-func xtm_multiplication
  (lambda (a:Complexf b:Complexf)
    (Cpxf (- (* (tref a 0) (tref b 0))
             (* (tref a 1) (tref b 1)))
          (+ (* (tref a 0) (tref b 1))
             (* (tref a 1) (tref b 0))))))

(bind-func xtm_multiplication
  (lambda (a:Complexf b:float)
    (Cpxf (- (* (tref a 0) b)
             (tref a 1))
          (+ (tref a 0)
             (* (tref a 1) b)))))

(bind-func xtm_multiplication
  (lambda (b:float a:Complexf)
    (Cpxf (- (* (tref a 0) b)
             (tref a 1))
          (+ (tref a 0)
             (* (tref a 1) b)))))

(bind-func Complex_multiplication_bybuf
  (let ((dd:/4,float/* (alloc)))
    (vfill! dd -1.0 1.0 -1.0 1.0)
    (lambda (a:Complexf* b:Complexf* c:Complexf* len:i64)
      (if (evenp len)
          (let ((j 0)
                (aa:/4,float/* (cast a))
                (bb:/4,float/* (cast b))
                (cc:/4,float/* (cast c)))
            (dotimes (j (/ len 2))
              (pset! cc j
                     (+ (* (vshuffle (pref-ptr aa j) null 0 0 2 2)
                           (vshuffle (pref-ptr bb j) null 0 1 2 3))
                        (* (* (vshuffle (pref-ptr aa j) null 1 1 3 3)
                              (vshuffle (pref-ptr bb j) null 1 0 3 2))
                           dd))))
            void)
          (let ((i 0))
            (dotimes (i len)
              (tset! (pref-ptr c i) 0
                     (- (* (tref (pref-ptr a i) 0)
                           (tref (pref-ptr b i) 0))
                        (* (tref (pref-ptr a i) 1)
                           (tref (pref-ptr b i) 1))))
              (tset! (pref-ptr c i) 1
                     (+ (* (tref (pref-ptr a i) 0)
                           (tref (pref-ptr b i) 1))
                        (* (tref (pref-ptr a i) 1)
                           (tref (pref-ptr b i) 0)))))
            void)))))

(bind-func xtm_division
  (lambda (a:Complexf b:Complexf)
    (let ((i (+ (* (tref a 0) (tref b 0))
                (* (tref a 1) (tref b 1))))
          (j (+ (* (tref b 0) (tref b 0))
                (* (tref b 1) (tref b 1))))
          (k (- (* (tref a 1) (tref b 0))
                (* (tref a 0) (tref b 1)))))
      (Cpxf (/ i j)
            (/ k j)))))

(bind-func xtm_division
  (lambda (a:Complexf b:float)
    (let ((i (+ (* (tref a 0) b)
                (tref a 1)))
          (j (* b b))
          (k (- (* (tref a 1) b)
                (tref a 0) )))
      (Cpxf (/ i j)
            (/ k j)))))

(bind-func xtm_division
  (lambda (b:float a:Complexf)
    (let ((i (+ (* (tref a 0) b)
                (tref a 1)))
          (j (* b b))
          (k (- (* (tref a 1) b)
                (tref a 0) )))
      (Cpxf (/ i j)
            (/ k j)))))

(bind-func Complex_division_bybuf
  (lambda (a:Complexf* b:Complexf* c:Complexf* len)
    (let ((i 0) (j 0.0) (k 0.0) (l 0.0))
      (dotimes (i len)
        (set! j (+ (* (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 1))))
        (set! k (+ (* (tref (pref-ptr b i) 0)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr b i) 1)
                      (tref (pref-ptr b i) 1))))
        (set! l (- (* (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 1))))
        (tset! (pref-ptr c i) 0 (/ j k))
        (tset! (pref-ptr c i) 1 (/ l k)))
      void)))


(bind-func Complex_mag
  (lambda (a:Complexf)
    (sqrt (+ (* (tref a 0) (tref a 0))
             (* (tref a 1) (tref a 1))))))

(bind-func Complex_phase
  (lambda (a:Complexf)
    (atan (/ (tref a 1) (tref a 0)))))

(bind-func Complex_conj
  (lambda (a:Complexf)
    (Cpxf (tref a 0)
          (* -1.0 (tref a 0)))))

(bind-func cart_to_pol
  (lambda (a:Complexf)
    (Cpxf (sqrt (+ (* (tref a 0) (tref a 0))
                   (* (tref a 1) (tref a 1))))
          (atan (/ (tref a 1) (tref a 0))))))

(bind-func cart_to_pol
  "transform a whole buffer cart->pol in-place"
  (lambda (a:Complexf* n:i64)
    (doloop (i n)
      (tset! (pref-ptr a i) 0
             (sqrt (+ (* (tref a 0) (tref a 0))
                      (* (tref a 1) (tref a 1)))))
      (tset! (pref-ptr a i) 1
             (atan (/ (tref a 1) (tref a 0)))))
    void))


(bind-func pol_to_cart
  (lambda (a:Complexf)
    (Cpxf (* (tref a 0) (cos (tref a 1)))
          (* (tref a 0) (sin (tref a 1))))))

(bind-func pol_to_cart
  "transform a whole buffer pol->cart in-place"
  (lambda (a:Complexf* n:i64)
    (doloop (i n)
      (tset! (pref-ptr a i) 0
             (* (tref a 0) (cos (tref a 1))))
      (tset! (pref-ptr a i) 1
             (* (tref a 0) (sin (tref a 1)))))
    void))

;; "bufferize" whole buffers of real & complex values (take two real
;; buffers with real & imaginary components, fill buffer of Complex
;; values)

(bind-func Complex_bufferize
  (lambda (re:float* im:float* com:Complexf* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr com i) 0 (pref re i))
        (tset! (pref-ptr com i) 1 (pref im i))))
    void))

(bind-func Complex_bufferize
  (lambda (re:float* com:Complexf* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr com i) 0 (pref re i))
        (tset! (pref-ptr com i) 1 0.0)))
    void))

(bind-func Complex_bufferize
  (lambda (re:double* im:double* com:Complexd* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr com i) 0 (pref re i))
        (tset! (pref-ptr com i) 1 (pref im i))))
    void))

(bind-func Complex_bufferize
  (lambda (re:double* com:Complexd* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr com i) 0 (pref re i))
        (tset! (pref-ptr com i) 1 0.0)))
    void))

;; do the opposite (take buffer of Complex, fill two real buffers with
;; real & imaginary components)

(bind-func Complex_unbufferize
  (lambda (com:Complexf* re:float* im:float* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (pset! re i (tref (pref-ptr com i) 0))
        (pset! im i (tref (pref-ptr com i) 1))))
    void))

(bind-func Complex_unbufferize
  (lambda (com:Complexf* re:float* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (pset! re i (tref (pref-ptr com i) 0)) ))
    void))

(bind-func Complex_unbufferize
  (lambda (com:Complexd* re:double* im:double* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (pset! re i (tref (pref-ptr com i) 0))
        (pset! im i (tref (pref-ptr com i) 1))))
    void))

(bind-func Complex_unbufferize
  (lambda (com:Complexd* re:double* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (pset! re i (tref (pref-ptr com i) 0)) ))
    void))

;;;;;;;;;;;;;;;
;; histogram ;;
;;;;;;;;;;;;;;;

;; currently uses floating-point values, i32 counts

(bind-type HistBin <float,float> (printer? . #f)
  "a histogram bin: <lower,count>")

(bind-func print
  "specialised print function for HistBin*"
  (lambda (histbin:HistBin*)
    (if (null? histbin)
        (printf "<HistBin 0x0>")
        (printf "<HistBin %p minval=%f count=%f>"
                histbin
                (convert (tref histbin 0) double)
                (convert (tref histbin 1) double)))
    void))

(bind-func toString
  "specialised toString function for HistBin*"
  (lambda (histbin:HistBin*)
    (let ((str:i8* (salloc 256)))
      (if (null? histbin)
          (sprintf str "<HistBin 0x0>")

          (sprintf str
                   "<HistBin %p minval=%f count=%f>"
                   histbin
                   (convert (tref histbin 0) double)
                   (convert (tref histbin 1) double)))
      (Str str))))


(bind-func histogram
  (lambda (hist:HistBin* buf:float* len lower upper nbins)
    (let ((current_bin:HistBin* null)
          (range (- upper lower)))
      (if (not (> range 0.))
          (begin
            (println "Error in histogram: range (- upper lower) must be greater than 0.0")
            null)
          (begin
            ;; setup the bins
            (doloop (i nbins)
              (tset! (pref-ptr hist i)
                     0
                     (+ lower (* (convert i) (/ range (convert nbins)))))
              (tset! (pref-ptr hist i)
                     1
                     0.))
            (doloop (i len)
              (set! current_bin
                    ;; use "mod nbins" to make sure it always goes
                    ;; into a valid slot in memory
                    (pref-ptr hist (% (convert (* (convert nbins float) (/ (- (pref buf i) lower) range)) i64) nbins)))
              (tset! current_bin 1 (+ (tref current_bin 1) 1.0)))
            hist)))))

(bind-func histogram
  "like the full version, but use the min and max values in the buffer as upper and lower"
  (lambda (hist:HistBin* buf:float* len nbins)
    (let ((lower 0.0)
          (upper 0.0))
      ;; find max/min values
      (doloop (i len)
        (if (< (pref buf i) lower)
            (set! lower (pref buf i)))
        (if (> (pref buf i) upper)
            (set! upper (pref buf i))))
      (histogram:[HistBin*,HistBin*,float*,i64,float,float,i64]* hist buf len lower upper nbins))))


;;;;;;;;;;
;; Misc ;;
;;;;;;;;;;

;; assorted maths-y functions.  not really sure where these should go

;; DFT/IDFT (for teaching purposes)

;; real in -> complex out
(bind-func dft
  (lambda (in:double* out:Complexd* len)
    (let ((n:i64 0) (k:i64 0) (tmp 0.0) (cpx:Complexd* null) (N (i64tod len)))
      (memset (cast out i8*) 0 (convert (* len 16)))
      (dotimes (k len)
        (set! cpx (pref-ptr out k))
        (dotimes (n len)
          (set! tmp (* (i64tod (* k n)) (/ TWOPI N)))
          (tset! cpx 0
                 (+ (tref cpx 0)
                    (* (pref in n) (cos tmp))))
          (tset! cpx 1
                 (- (tref cpx 1)
                    (* (pref in n) (sin tmp))))))
      void)))

;; complex in -> real out
(bind-func idft
  (lambda (in:Complexd* out:double* len)
    (let ((n:i64 0) (k:i64 0) (tmp 0.0) (cpx:Complexd* null) (N (i64tod len)))
      (dotimes (n len)
        (pset! out n 0.0)
        (dotimes (k len)
          (set! cpx (pref-ptr in k))
          (set! tmp (* (i64tod (* k n)) (/ TWOPI N)))
          (pset! out n
                 (+ (pref out n)
                    (- (* (tref cpx 0) (cos tmp))
                       (* (tref cpx 1) (sin tmp))))))
        ;; scale
        (pset! out n (/ (pref out n) N)))
      void)))

;; gaussian random number X ~ N(0,1)
;; algorithm by Marsaglia http://c-faq.com/lib/gaussian.html

(bind-func gaussr
  (let ((phase 0))
    (lambda ()
      (let ((u1:double (random))
            (u2:double (random))
            (v1 (- (* 2.0 u1) 1.0))
            (v2 (- (* 2.0 u2) 1.0))
            (s (+ (* v1 v1) (* v2 v2))))
        (if (= phase 0)
            (if (or (> s 1.0) (= s 0.0) (= s 1.0))
                (gaussr)
                (* v1 (sqrt (/ (* -2.0 (log s)) s))))
            (begin (set! phase (- 1 phase))
                   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))

(bind-func gaussr
  (let ((phase 0))
    (lambda ()
      (let ((u1:float (random))
            (u2:float (random))
            (v1 (- (* 2.0 u1) 1.0))
            (v2 (- (* 2.0 u2) 1.0))
            (s (+ (* v1 v1) (* v2 v2))))
        (if (= phase 0)
            (if (or (> s 1.0) (= s 0.0) (= s 1.0))
                (gaussr)
                (* v1 (sqrt (/ (* -2.0 (log s)) s))))
            (begin (set! phase (- 1 phase))
                   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))


;; where t is time between [0.0 - 1.0]
(bind-func hanning
  (lambda (t)
    (- 0.5 (* 0.5
              (cos (* TWOPI t))))))

(bind-func window_hanning
  (let ((i:i64 0))
    (lambda (window_buffer:double* window_length)
      (dotimes (i window_length)
        (pset! window_buffer i
               (* (pref window_buffer i)
                  (- 0.5 (* 0.5 (cos (/ (* TWOPI (i64tod i))
                                        (i64tod (- window_length 1)))))))))
      void)))

(bind-func window_hanning
  (let ((i:i64 0))
    (lambda (window_buffer:float* window_length)
      (dotimes (i window_length)
        (pset! window_buffer i
               (* (pref window_buffer i)
                  (- 0.5 (* 0.5 (cos (/ (* TWOPIf (i64tof i))
                                        (i64tof (- window_length 1)))))))))
      void)))


;; where to is [0.0 - 1.0]
(bind-func hamming
  (lambda (t)
    (- 0.54 (* 0.46 (cos (* TWOPI t))))))

(bind-func window_hamming
  (let ((i:i64 0))
    (lambda (window_buffer:double* window_length)
      (dotimes (i window_length)
        (pset! window_buffer i
               (* (pref window_buffer i)
                  (- 0.54 (* 0.46 (cos (/ (* TWOPI (i64tod i))
                                          (i64tod (- window_length 1)))))))))
      void)))

(bind-func window_hamming
  (let ((i:i64 0))
    (lambda (window_buffer:float* window_length)
      (dotimes (i window_length)
        (pset! window_buffer i
               (* (pref window_buffer i)
                  (- 0.54 (* 0.46 (cos (/ (* TWOPIf (i64tof i))
                                          (i64tof (- window_length 1)))))))))
      void)))

;; string hashing functions

(bind-func djb2
  (lambda (str:i8*)
    (let ((hash:i64 5381)
          (len (strlen str))
          (i 0))
      (dotimes (i len)
        (set! hash (+ (<< hash 5) hash (convert (pref str i)))))
      hash)))

(bind-func sdbm
  (lambda (str:i8*)
    (let ((hash:i64 0)
          (len (strlen str))
          (i 0))
      (dotimes (i len)
        (set! hash (- (+ (convert (pref str i)) (<< hash 6) (<< hash 16)) hash)))
      hash)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; numeric integration and differentiation
;;
;; numeric diff with floats is error prone (precision)
;; try to stick to double precision and convert results
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func diff
  "numeric differentiation - central diff"
  (lambda (f:[double,double]* x)
    (/ (- (f (+ x (/ 1e-5 2.0)))
          (f (- x (/ 1e-5 2.0))))
       1e-5)))

(bind-func diff
  "numeric differentiation - central diff"
  (lambda (f:[double,double]* x dx)
    (/ (- (f (+ x (/ dx 2.0)))
          (f (- x (/ dx 2.0))))
       dx)))

;; same as above (i.e. central)
(bind-func differentiate
  "numeric differentiation - central diff"
  (lambda (f:[double,double]* x)
    (/ (- (f (+ x (/ 1e-5 2.0)))
          (f (- x (/ 1e-5 2.0))))
       1e-5)))

(bind-func diff_extrapolated
  "numeric differentiation - extrapolated diff"
  (lambda (f:[double,double]* x dx)
    (/ (- (* 8.0 (- (f (+ x (/ dx 4.0)))
                    (f (- x (/ dx 4.0)))))
          (- (f (+ x (/ dx 2.0)))
             (f (- x (/ dx 2.0)))))
       (* 3.0 dx))))

(bind-func diff2
  "numeric differentiation (2nd deriv) - central diff"
  (lambda (f:[double,double]* x)
    (/ (- (- (f (+ x 1e-5)) (f x))
          (- (f x) (f (- x 1e-5))))
       (* 1e-5 1e-5))))

(bind-func diff2
  "numeric differentiation (2nd deriv) - central diff"
  (lambda (f:[double,double]* x dx)
    (/ (- (- (f (+ x dx)) (f x))
          (- (f x) (f (- x dx))))
       (* dx dx))))

(bind-func integrate
  "integrate using Simpsons rule - N must be odd"
  (lambda (f:[double,double]* xmin xmax N)
    (let ((sumeven:double 0.0)
          (sumodd:double 0.0)
          (x 0.0) (n 0)
          (interval (/ (- xmax xmin) (i64tod (- N 1)))))
      (set! n 2)
      (while (< n N)
        (set! x (+ xmin (* interval (i64tod (- n 1)))))
        (set! sumodd (+ sumodd (f x)))
        (set! n (+ n 2)))
      (set! n 3)
      (while (< n N)
        (set! x (+ xmin (* interval (i64tod (- n 1)))))
        (set! sumeven (+ sumeven (f x)))
        (set! n (+ n 2)))
      (* (+ (* sumeven 2.0) (* sumodd 4.0)
            (f xmin) (f xmax))
         (/ interval 3.0)))))

(bind-func integrate
  "integrate using Simpsons rule - N must be odd"
  (lambda (f:[double,double]* xmin xmax)
    (integrate:[double,[double,double]*,double,double,i64]* f xmin xmax 501)))


;; end libs/core/math.xtm

(define *xtmlib-math-loaded* #t)
(impc:aot:insert-footer "xtmmath")
